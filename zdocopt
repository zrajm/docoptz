#!/bin/sh

#DEBUG=1
if [ "$DEBUG" ]; then
    DEBUG() { {
        printf '%s\n' "$1"; shift
        printf '    %s\n' "$@"
    } >&2; }
else
    DEBUG() { :; }
fi

################################################################################

die() {
    printf '%s: %s\n' "${0##*/}" "$*"
    exit 5
}
testname() {
    H="${1:+$1: }"; shift
    for V in "$@"; do
        case "$V" in *[!A-Z0-9_]*|[0-9]*) die "${H}Bad varname '$V'"; esac
    done
}
testint() {
    H="${1:+$1: }"; shift
    for V in "$@"; do
        case "$V" in *[!0-9]*) die "${H}Bad integer '$V'"; esac
    done
}
# Usage: getvar VARNAME1 VARNAME2
#
# Variable VARNAME1 is set to whatever variable VARNAME2 contains.
getvar() { testname getvar "$1" "$2"; _getvar "$@"; }
_getvar() { eval "$1=\"\$$2\""; }

# Usage: setvar VARNAME VALUE
#
# Set variable VARNAME to the specified value.
setvar() { testname setvar "$1"; _setvar "$@"; }
_setvar() { eval "$1=\"\$2\""; }

# Usage: incvar VARNAME
#
# Sets variable VARNAME to 0 if unset, otherwise increment VARNAME by one.
incvar() { testname incvar "$1"; _incvar "$@"; }
_incvar() { eval "$1=\"\$((\${$1:--1} + 1))\""; } #VAR="$((${VAR:--1} + 1))"

# Usage: VARNAME VALUE
#
# Set varible VARNAME to VALUE, except remove all trailing '.0' first.
stripzeroes() {
    #R="$STATE"
    #while [ "$R" != "${R%.0}" ]; do R="${R%.0}"; done
    eval "$1=\"\$2\";
    while [ \"\$$1\" != \"\${$1%.0}\" ]; do $1=\"\${$1%.0}\"; done"
}

# Usage: increment_state STATE
#
# Where STATE is a number like '0' or '1.2' or '0.2.3'. Increments last digit
# of state by one.
increment_state() {
    # case "$STATE" in
    #     *.*) STATE="${STATE%.*}.$((${STATE##*.}+1))";;
    #     *) STATE="$((STATE+1))"
    # esac
    testname increment_state "$1"
    eval "case \"\$$1\" in
        *.*) $1=\"\${$1%.*}.\$((\${$1##*.}+1))\";;
        *) $1=\"\$(($1+1))\"
    esac"
}

# Usage: LEVELVAR STATEVAR
#
# Goes one level deeper into hierarchy, by adding one to LEVELVAR and appending
# a '.SUBSTATE' number to STATEVAR. SUBSTATE is guaranteed to be unique for
# each LEVEL. (Uses forever incrementing variables ${LAST$LVL} to keep track of
# which substates to use.)
add_substate() {
    testname add_substate "$1" "$2"
    local _LVL
    _incvar "$1"                      # increment level
    _getvar _LVL "$1"                 #   get level value
    testint add_substate "$_LVL"
    _incvar "LAST$_LVL"               # increment last substate
    # STATE="$STATE.${LAST$_LVL}"
    eval "$2=\"\$$2.\$LAST$_LVL\""    # append last substate to state
}

remove_substate() {
    testname remove_substate "$2"
    # LVL="$((LVL-1))"
    #eval "$1=\"\$(($1-1))\""  # decrement LVL
    setvar "$1" "$(($1-1))"    # decrement LVL
    # STATE="${STATE%.*}"
    eval "$2=\"\${$2%.*}\""    # remove number from STATE
}

# Usage: remove_level STATE LVL
remove_level() {
    # LVL="$((LVL-1))"
    #eval "$1=\"\$(($1-1))\""  # decrement LVL
    setvar "$1" "$(($1-1))"    # decrement LVL
    # STATE="${STATE%.*}"
    testname remove_level "$2"
    eval "$2=\"\${$2%.*}\""    # remove number from STATE
}

output_rule() {
    local STATE="$2" _RULE
    getvar _RULE "$1"
    [ "$_RULE" ] && printf "%s -> %s\n" "$_RULE" "$STATE"
    unset "$1"
}

parsy() {
    printf '%s\n' "$*"
    local LVL=0 RULE='' STATE=0
    for A in "$@"; do
        DEBUG="$A"
        case "$A" in
            '('|'[')                           # start parenthesis or bracket
                output_rule RULE "$STATE"
                add_substate LVL STATE         #   add substate
                setvar "BEG$LVL" "$STATE"      #     remember opening state
            ;;
            ')')                               # end parenthesis
                # FIXME: STATE should end in '.x'
                output_rule RULE "${STATE%.*}.x"
                unset "BEG$LVL"                #   forget opening state
                remove_level LVL STATE
                increment_state STATE
            ;;
            ']')                               # end bracket
                # FIXME: STATE should end in '.x'
                output_rule RULE "${STATE%.*}.x"
                unset "BEG$LVL"                #   forget opening state
                remove_level LVL STATE
            ;;
            '|')                               #   pipe
                # FIXME: STATE should end in '.x'
                output_rule RULE "${STATE%.*}.x"
                getvar STATE "BEG$LVL"         #     return state to start bracket
            ;;
            *)                                 #   anything else
                output_rule RULE "$STATE"

                stripzeroes REDUCED "$STATE"
                #echo "REDUCED:$STATE -> $REDUCED"
                REDUCED="$STATE"
                while [ "$REDUCED" != "${REDUCED%.0}" ]; do
                    REDUCED="${REDUCED%.0}"
                done

                RULE="$REDUCED:$A"
                increment_state STATE
                #setvar "USED$LVL" "${STATE##*.}"
                # increase USED
            ;;
        esac
        local USED BEG
        getvar USED "USED$LVL"
        getvar BEG  "BEG$LVL"

        DEBUG "$DEBUG" "STATE: $STATE" "LVL: $LVL" "BEG$LVL: $BEG" "USED$LVL: $USED"
    done
    if [ "$LVL" -gt 0 ]; then
        die "Too few ending parentheses!!"
    fi
}

################################################################################

:<<'BLOCK_COMMENT'

#parsy thingy '(' ')' '(' ')' '(' ')' '(' ')'

parsy thingy '[' tool '|' lamp ']' '(' on '|' off ')' '(' green '|' blue ')'

echo --------------------------------------------------------------------------------
X="( lamp | machine ) ( on | off | dim VALUE )"

cat <<EOF
EXPECTED
$X
0:lamp -> 1
0:machine -> 1
1:on -> 2
1:off -> 2
1:dim -> 1.1
1.1:* -> 2
EOF

parsy $X

echo --------------------------------------------------------------------------------
X="0 ( 0.0 a 0.1 (0.1.0 b 0.1.1 (0.1.1.0 c 0.1.1.1 )  ) ) 1"
X="( a ( b ( c ) ) )"
cat <<EOF
EXPECTED
$X
0:a -> 0.1
0.1:b -> 0.1.0
1.1:c -> 1
EOF

parsy $X

BLOCK_COMMENT

echo --------------------------------------------------------------------------------
LINE='my_program go ( --up | --down | --left | --right )'

cat <<EXPECTED
$LINE
0:go -> 1
1:--up -> 2
1:--down -> 2
1:--left -> 2
1:--right -> 2
DONE=2
--------------------
EXPECTED
LINE="${LINE#* }"
parsy $LINE

#[eof]

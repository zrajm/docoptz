#!/bin/sh

#set -euv

# FIXME: Remove dead code

#DEBUG=1
if [ "$DEBUG" ]; then
    DEBUG() { {
        printf '%s\n' "$1"; shift
        printf '    %s\n' "$@"
    } >&2; }
else
    DEBUG() { :; }
fi

################################################################################

out() { printf '%s\n' "$*"; }
die() { warn "$@"; exit 5; }
warn() { printf '%s: %s\n' "${0##*/}" "$*" >&2; :; } # always return true
varname_or_die() {
    local H V
    H="${1:+$1: }"; shift
    for V in "$@"; do
        case "$V" in *[!A-Z0-9_]*|[0-9]*) die "${H}Bad variable name '$V'"; esac
    done
}
int_or_die() {
    local H V
    H="${1:+$1: }"; shift
    for V in "$@"; do
        case "$V" in *[!0-9]*) die "${H}Bad integer '$V'"; esac
    done
}
# Usage: getvar VARNAME1 VARNAME2
#
# Variable VARNAME1 is set to whatever variable VARNAME2 contains.
getvar() { varname_or_die getvar "$1" "$2"; _getvar "$@"; }
_getvar() { eval "$1=\"\$$2\""; }

# # Usage: getvar VARNAME1 VARNAME2
# #
# # Variable VARNAME1 is set to whatever variable VARNAME2 contains.
# getint() { varname_or_die getint "$1" "$2"; _getint "$@"; }
# _getint() {
#     eval "$1=\"\$$2\"";
#     int_or_die getint "$1";
# }

# Usage: append VARNAME STRING
#
# Append STRING to VARNAME with a space inbetween (unless VARNAME is empty, in
# which case no space is inserted in front of STRING).
append() {
    varname_or_die append "$1";
    # VARNAME="${VARNAME:+$VARNAME }$2"
    eval "$1=\"\${$1:+\$$1 }\$2\""
}

# Usage: appendnl VARNAME STRING
#
# Append STRING to VARNAME with a space inbetween (unless VARNAME is empty, in
# which case no space is inserted in front of STRING).
appendnl() {
    varname_or_die append "$1";
    # VARNAME="${VARNAME:+$VARNAME<NEWLINE>}$2"
    eval "$1=\"\${$1:+\$$1
}\$2\""                                        # intentional newline
}

# Usage: setvar VARNAME VALUE
#
# Set variable VARNAME to the specified value.
setvar() { varname_or_die setvar "$1"; _setvar "$@"; }
_setvar() { eval "$1=\"\$2\""; }

# Usage: incvar VARNAME
#
# Sets variable VARNAME to 0 if unset, otherwise increment VARNAME by one.
#incvar() { varname_or_die incvar "$1"; _incvar "$@"; }
_incvar() { eval "$1=\"\$((\${$1:--1} + 1))\""; } #VAR="$((${VAR:--1} + 1))"

# Usage: decvar VARNAME
#
# Sets variable VARNAME to 0 if unset, otherwise decrement VARNAME by one.
#decvar() { varname_or_die decvar "$1"; _decvar "$@"; }
_decvar() { _setvar "$1" "$(($1 - 1))"; }

# Usage: parse TOKENIZED
#
# Go through TOKENIZED and create finite-state machine rules suitable for
# parsing a command line. Also checks the validity/nesting of (...) and [...]
# constructs. (Failing if brackets or parentheses are unbalanced.)
#
# The following special characters are recognized:
#   * Group start: '[' or '('
#   * Group end: ']' or ')'
#   * Subgroup separator: '|'
#   * Group repeat: '...'
#
# The beginning of a subgroup can be attached to one or more states (if the
# previous subgroup[s] where optional). The first part of each subgroup is
# therefore connected to all the STARTAT states (space-separated list state
# identifiers). The remaining group states should be the same regardless of
# which 'entry' was taken.
#
# Internals:
#
# LVL is the current level of nesting. GROUPS in the number of the current
# parenthesis. In '()()' GROUPS is 1 and 2, and LVL 0 and 1. In '(())' GROUPS
# is also 1 & 2, but LVL is 0 (outside paren), 1 (inside first paren), and 2
# (inside innermost paren). I.e. GROUPS never decreases, while LVL does. IN is
# the current group we're in, so in '()()' it looks like this '0(1)0(2)0',
# while in '(())' its '0(1(2)1)0'.

#
# GROUP0...N is a pseudo-array containing group stack. It has no meaning
# outside this loop. It contains the group number of the current parenthetical
# group at the end.
#
# TYPE0...N is pseudo-array containing group type. TYPE0='' (because its not
# within brackets), all higher numbers are either ']' or ')' depending on
# whether it's a [...] or (...) group.
#
# FIXME: With [...] some leading and final rules will be needed twice: Implement!
# FIXME: Export _DEBUG_RULES in some 'appropriate' way
# FIXME: Implement finishing rules (instead of final states)
# FIXME: Stop using $IN and $GROUP? (if possible)

# ELLIPSIS RULES
# ==============
# Ellipsis rules are extra rules built up during the processing of each group,
# which are only inserted into the final ruleset if the group in question is
# followed by '...'. They are the purple rules in the finite state machine
# images, and they allow for repetition.
parse() {
    local STARTAT=0                            # startat 'array' length
    local STATE=0 STATECOUNT=0
    local TYPE=''
    local OUT='' END=''
    _DEBUG_STATE=''                            # used in testing
    _DEBUG_GROUP=''
    _DEBUG_LEVEL=''
    _DEBUG_RULES=''
    local LVL=0 GROUPS=0 IN=0 GROUP0=0 TYPE0=''

    # Loop over $@ while setting $A to current arg, and $NEXT to next arg.
    local I=0 A='' NEXT='' PREV='' OLDSTATE='' ENDSTATE='' ELLIPSIS='' TMP=''
    while I="$(( I + 1 ))"; [ "$I" -le "$#" ]; do
        eval    A="\"\$$I\""                   # current arg
        eval NEXT="\"\$$(( I + 1 ))\""         #   next arg
        append _DEBUG_STATE "$STATE $A"
        append _DEBUG_GROUP "$IN $A"
        append _DEBUG_LEVEL "$LVL $A"
        case "$A" in
            ['(['])                            # start parenthesis or bracket
                _incvar LVL                    #   group level
                _incvar GROUPS                 #   group number
                IN="$GROUPS"                   #   current group number
                local "GROUP$LVL"="$GROUPS"    #   loop stack: group number stack
                case "$A" in                   #   loop stack: group types
                    '(') local "TYPE$LVL"=')' ;;
                    '[') local "TYPE$LVL"=']' ;;
                esac
                _incvar STATECOUNT
                local "BEG$IN"="$STATE"        #   set group start state
                local "END$IN"="$STATECOUNT"   #   set group end state
                #local "ELLIPSIS$IN"=""         #   clear ellipsis rules
                ;;
            '|')                               # pipe
                _getvar STATE "BEG$IN"         #   return to group start state
                ;;
            ['])'])                            # end bracket
                _getvar TYPE "TYPE$LVL"
                [ "$LVL" -le 0    ] && warn "Too many '$A' in rule: $*" && return 1
                [ "$A" != "$TYPE" ] && warn "Missing '$A' in rule (group $IN): $*" && return 1

                #_getvar STATE "END$IN"          #     return state to start bracket

                # Apply ellipsis rules if followed by '...'.
                if [ "$NEXT" = '...' ]; then
                    _getvar ELLIPSIS "ELLIPSIS$IN"
                    #appendnl "_DEBUG_RULES" "$STATE:$ELLIPSIS"
                    #HEREHERE

                    prefix TMP "$STATE:" "$ELLIPSIS"
                    appendnl "_DEBUG_RULES" "$TMP"

                    # ## PREFIX every row of ELLIPSIS with STATE instead of the following
                    # out "$ELLIPSIS" | while IFS='' read -r LINE; do
                    #     echo ">>>>>$STATE:$LINE"
                    #     appendnl "_DEBUG_RULES" "$STATE:$LINE"
                    # done
                fi

                unset "GROUP$LVL" "TYPE$LVL"   #   remove from group stack
                _decvar LVL                    #   go down one level
                _getvar IN "GROUP$LVL"         #   current group number
                # FIXME: These lines not covered by test cases!! (necessary?)
                case "$NEXT" in [')]'])
                    local "END$IN"="$STATE"
                esac
                ;;
            '...')                             # ellipsis
                # '...' are handled at the end of the ')' / ']' state, and
                # therefore just ignored here.
                ## FIXME: Syntax check: may only come after WORD, ']' or ')'
                ;;
            *)                                 # anything else
                OLDSTATE="$STATE"
                _getvar ENDSTATE "END$IN"
                case "$NEXT" in                #   last in bracket group
                    ['|)]'])                   #     use last state of bracket
                        STATE="$ENDSTATE" ;;
                    *)                         #   otherwise
                        _incvar STATECOUNT     #     increase state by one
                        STATE="$STATECOUNT" ;;
                esac
                appendnl _DEBUG_RULES "$OLDSTATE:$A -> $STATE"
                case "$PREV" in ['[(|'])       # add ellipsis rule
                    local "ELLIPSIS$IN"
                    appendnl "ELLIPSIS$IN" "$A -> $STATE"
                esac
                ;;
        esac
        # # DEBUG: Indented parse output
        # local DEBUG_INDENT DEBUG_INDENT_NEXT
        # case "$A" in
        #     '('|'[')                           # start parenthesis or bracket
        #         DEBUG_INDENT_NEXT="    $DEBUG_INDENT" ;;
        #     ']'|')')                           # end bracket
        #         DEBUG_INDENT="${DEBUG_INDENT#    }"
        #         DEBUG_INDENT_NEXT="$DEBUG_INDENT" ;;
        #     '|')                               #   pipe
        #         DEBUG_INDENT_NEXT="$DEBUG_INDENT"
        #         DEBUG_INDENT="${DEBUG_INDENT#  }" ;;
        # esac
        # out "$DEBUG_INDENT>>$A"
        # out "  ${DEBUG_INDENT}LVL:$LVL STATE:$STATE"
        # DEBUG_INDENT="$DEBUG_INDENT_NEXT"
        PREV="$A"
    done
    unset "GROUP0"  # last element of group stack
    unset "TYPE0"
    append _DEBUG_STATE "$STATE"
    append _DEBUG_GROUP "$IN"
    append _DEBUG_LEVEL "$LVL"
    if [ "$LVL" -ne 0 ]; then
        local PAREN; _getvar PAREN "TYPE$LVL"
        warn "Missing '$PAREN' at end of rule: $*"
        return 1
    fi
}

ok_varname() {
    local H V
    H="${1:+$1: }"; shift
    for V in "$@"; do
        case "$V" in
            *[!A-Z0-9_]*|[0-9]*)
                warn "${H}Bad variable name '$V'"
                return 1
        esac
    done
    return 0
}

ok_int() {
    local H V
    H="${1:+$1: }"; shift
    for V in "$@"; do
        case "$V" in
            *[!0-9]*)
                warn "${H}Bad integer '$V'"
                return 1
        esac
    done
    return 0
}

# Usage: VARNAME PREFIX STRING
#
# Prefix every line in STRING with PREFIX, return in VARNAME.
prefix() {
    local _VAR="$1" _PRE="$2" _ARG='' IFS='
'                                              # intentional newline
    ok_varname prefix "$_VAR" || return 1      # verify VARNAME
    set -- $3                                  # intentionally unquoted
    for _ARG in "$@"; do
        shift
        set "$@" "$_PRE$_ARG"
    done
    eval "$_VAR"="\$*"
}

################################################################################
##                                                                            ##
##  Test "Framework"                                                          ##
##                                                                            ##
################################################################################

TESTS_DONE=''
TMPDIR="$(mktemp -dt zdocpt2-XXXXXX)"
TMPNUM="0"
BIN="${0##*/}"
trap "trap - EXIT INT
     [ -d '$TMPDIR' ] && rm -r '$TMPDIR';
     [ \"\$TESTS_DONE\" ] || out '***PREMATURE EXIT! Not all tests ran!';
     exit" EXIT INT

# Usage: tmpfile VARNAME
#
# Sets variable VARNAME to next suitable tempfile.
tmpfile() { setvar "$1" "$TMPDIR/$TMPNUM"; _incvar TMPNUM; }

# # Usage: printfmultiline FORMAT1 FORMAT2 STUFF
# printfnl() {
#     local FMT="$1" FMT2="$2" X; shift 2
#     local LINE IFS='
# ';  set -- $@                                  # intentionally unquoted
#     out '----------------------------------------'
#     for LINE in "$@"; do
#         printf "$FMT\n" "$LINE"
#         FMT="$FMT2"
#     done
# }

FAILED_TESTS=0
TESTS_COUNT=0
# FIXME: Arg order SHOULD BE: GOT EXPECTED [MESSAGE] (from perl's Tests::More)
# FIXME: Also fix arg order in all invokations
test() {
    local MSG="$1" EXPECTED="$2" GOT="$3" EXTRA="$4"
    TESTS_COUNT="$(( TESTS_COUNT + 1 ))"
    if [ "$GOT" != "$EXPECTED" ]; then
        out "Test failed!!!"
        out "    $MSG"
        [ "$EXTRA" ] && out "    EXTRA   :  $EXTRA"
        local FILE1='' FILE2=''; tmpfile FILE1; tmpfile FILE2
        { out 'EXPECTED'; out "$EXPECTED"; } >"$FILE1"
        { out 'GOT';      out "$GOT";      } >"$FILE2"
        local WIDTH="$(( $(wc -L <"$FILE1") + $(wc -L <"$FILE2") + 8 ))"
        [ "$WIDTH" -gt "$COLUMNS" ] && WIDTH="$COLUMNS"
        diff --width="$WIDTH" --color=always --expand-tabs \
             --side-by-side "$FILE1" "$FILE2" | \
            while IFS='' read -r LINE; do echo "    $LINE\e[m"; done
        out '----------------------------------------'
        #printfnl '    EXPECTED: %s' '              %s' "$EXPECTED"
        #printfnl '     BUT GOT: %s' '              %s' "$GOT"
        FAILED_TESTS="$(( FAILED_TESTS + 1 ))"
    fi
}

done_testing() {
    TESTS_DONE=1
    if [ "$FAILED_TESTS" -gt 0 ]; then
        printf '==============================================\n'
        printf '== %-40s ==\n' 'ERRORS!!!!!!!!!!!!11111!!!'
        printf '== %-40s ==\n' "$FAILED_TESTS (of $TESTS_COUNT) tests failed!"
        printf '==============================================\n'
        exit 10
    else
        printf "All %s tests passed.\n" "$TESTS_COUNT"
    fi
}

# Usage: dumpenv VARNAME...
#
# Outputs all environment variables to standard output (usin `set`) except
# those specified on the command line. All named variables are locally unset
# before outputting the variables but restored upon exiting the function.
dumpenv() {
    for VAR in "$@"; do
        local "$VAR"
        unset "$VAR"
    done
    set
}

################################################################################
##                                                                            ##
##  Tests                                                                     ##
##                                                                            ##
################################################################################

######################################################################
##
##  Test parse() error messages
##

## One ')' too many
INPUT='A )'
tmpfile TMPFILE
parse $INPUT 2>"$TMPFILE"; RETVAL="$?"         # intentionally unquoted
read ERRMSG <"$TMPFILE"
test 'Return value'  "1" "$RETVAL"
test 'Error message' "$BIN: Too many ')' in rule: A )" "$ERRMSG"

## One ']' too many
INPUT='A ]'
tmpfile TMPFILE
parse $INPUT 2>"$TMPFILE"; RETVAL="$?"         # intentionally unquoted
read ERRMSG <"$TMPFILE"
test 'Return value'  "1" "$RETVAL"
test 'Error message' "$BIN: Too many ']' in rule: A ]" "$ERRMSG"

## Missing ')'
INPUT='[ A )'
tmpfile TMPFILE
parse $INPUT 2>"$TMPFILE"; RETVAL="$?"         # intentionally unquoted
read ERRMSG <"$TMPFILE"
test 'Return value'  "1" "$RETVAL"
test 'Error message' "$BIN: Missing ')' in rule (group 1): [ A )" "$ERRMSG"

## Missing ']'
INPUT='( A ]'
tmpfile TMPFILE
parse $INPUT 2>"$TMPFILE"; RETVAL="$?"
read ERRMSG <"$TMPFILE"
test 'Return value'  "1" "$RETVAL"
test 'Error message' "$BIN: Missing ']' in rule (group 1): ( A ]" "$ERRMSG"

## Missing ']'
INPUT='( A'
tmpfile TMPFILE
parse $INPUT 2>"$TMPFILE"; RETVAL="$?"
read ERRMSG <"$TMPFILE"
test 'Return value'  "1" "$RETVAL"
test 'Error message' "$BIN: Missing ')' at end of rule: ( A" "$ERRMSG"

######################################################################
##
##  Test Actual Results
##

INPUT='  A'
LEVEL='0 A 0'
GROUP='0 A 0'
STATE='0 A 1'; FINAL='1'
RULES='0:A -> 1'
parse $INPUT; RETVAL="$?"                      # intentionally unquoted
test 'Return value'     "0"      "$RETVAL"
test 'Bracket level'    "$LEVEL" "$_DEBUG_LEVEL" "$INPUT"
test 'Group numbers'    "$GROUP" "$_DEBUG_GROUP" "$INPUT"
test 'State numbers'    "$STATE" "$_DEBUG_STATE" "$INPUT"
test 'Rules'            "$RULES" "$_DEBUG_RULES" "$INPUT"

INPUT='  A   B'
LEVEL='0 A 0 B 0'
GROUP='0 A 0 B 0'
STATE='0 A 1 B 2'; FINAL='2'
RULES='0:A -> 1
1:B -> 2'
parse $INPUT; RETVAL="$?"                      # intentionally unquoted
test 'Return value'     "0"      "$RETVAL"
test 'Bracket level'    "$LEVEL" "$_DEBUG_LEVEL" "$INPUT"
test 'Group numbers'    "$GROUP" "$_DEBUG_GROUP" "$INPUT"
test 'State numbers'    "$STATE" "$_DEBUG_STATE" "$INPUT"
test 'Rules'            "$RULES" "$_DEBUG_RULES" "$INPUT"

INPUT='  (   A   )   B'
LEVEL='0 ( 1 A 1 ) 0 B 0'
GROUP='0 ( 1 A 1 ) 0 B 0'
STATE='0 ( 0 A 1 ) 1 B 2'; FINAL='2'
RULES='0:A -> 1
1:B -> 2'
parse $INPUT; RETVAL="$?"                      # intentionally unquoted
test 'Return value'     "0"      "$RETVAL"
test 'Bracket level'    "$LEVEL" "$_DEBUG_LEVEL" "$INPUT"
test 'Group numbers'    "$GROUP" "$_DEBUG_GROUP" "$INPUT"
test 'State numbers'    "$STATE" "$_DEBUG_STATE" "$INPUT"
test 'Rules'            "$RULES" "$_DEBUG_RULES" "$INPUT"

INPUT='  (   A   )   (   B   )'
LEVEL='0 ( 1 A 1 ) 0 ( 1 B 1 ) 0'
GROUP='0 ( 1 A 1 ) 0 ( 2 B 2 ) 0'
STATE='0 ( 0 A 1 ) 1 ( 1 B 2 ) 2'; FINAL='2'
RULES='0:A -> 1
1:B -> 2'
parse $INPUT; RETVAL="$?"                      # intentionally unquoted
test 'Return value'     "0"      "$RETVAL"
test 'Bracket level'    "$LEVEL" "$_DEBUG_LEVEL" "$INPUT"
test 'Group numbers'    "$GROUP" "$_DEBUG_GROUP" "$INPUT"
test 'State numbers'    "$STATE" "$_DEBUG_STATE" "$INPUT"
test 'Rules'            "$RULES" "$_DEBUG_RULES" "$INPUT"

INPUT='  (   (   A   )   B   )'
LEVEL='0 ( 1 ( 2 A 2 ) 1 B 1 ) 0'
GROUP='0 ( 1 ( 2 A 2 ) 1 B 1 ) 0'
STATE='0 ( 0 ( 0 A 2 ) 2 B 1 ) 1'; FINAL='1'
RULES='0:A -> 2
2:B -> 1'
parse $INPUT; RETVAL="$?"                      # intentionally unquoted
test 'Return value'     "0"      "$RETVAL"
test 'Bracket level'    "$LEVEL" "$_DEBUG_LEVEL" "$INPUT"
test 'Group numbers'    "$GROUP" "$_DEBUG_GROUP" "$INPUT"
test 'State numbers'    "$STATE" "$_DEBUG_STATE" "$INPUT"
test 'Rules'            "$RULES" "$_DEBUG_RULES" "$INPUT"

INPUT='  (   A   (   B   )   )'
LEVEL='0 ( 1 A 1 ( 2 B 2 ) 1 ) 0'
GROUP='0 ( 1 A 1 ( 2 B 2 ) 1 ) 0'
STATE='0 ( 0 A 2 ( 2 B 3 ) 3 ) 3'; FINAL='3' # (state 1 never used)
RULES='0:A -> 2
2:B -> 3'
parse $INPUT; RETVAL="$?"                      # intentionally unquoted
test 'Return value'     "0"      "$RETVAL"
test 'Bracket level'    "$LEVEL" "$_DEBUG_LEVEL" "$INPUT"
test 'Group numbers'    "$GROUP" "$_DEBUG_GROUP" "$INPUT"
test 'State numbers'    "$STATE" "$_DEBUG_STATE" "$INPUT"
test 'Rules'            "$RULES" "$_DEBUG_RULES" "$INPUT"

INPUT='  (   A   (   B   (   C   )   )   )'
LEVEL='0 ( 1 A 1 ( 2 B 2 ( 3 C 3 ) 2 ) 1 ) 0'
GROUP='0 ( 1 A 1 ( 2 B 2 ( 3 C 3 ) 2 ) 1 ) 0'
STATE='0 ( 0 A 2 ( 2 B 4 ( 4 C 5 ) 5 ) 5 ) 5'; FINAL='3' # (state 1 & 3 never used)
RULES='0:A -> 2
2:B -> 4
4:C -> 5'
parse $INPUT; RETVAL="$?"                      # intentionally unquoted
test 'Return value'     "0"      "$RETVAL"
test 'Bracket level'    "$LEVEL" "$_DEBUG_LEVEL" "$INPUT"
test 'Group numbers'    "$GROUP" "$_DEBUG_GROUP" "$INPUT"
test 'State numbers'    "$STATE" "$_DEBUG_STATE" "$INPUT"
test 'Rules'            "$RULES" "$_DEBUG_RULES" "$INPUT"

INPUT='  (   A   B   C   |   D   E   F   |   G   H   I   )   X'
LEVEL='0 ( 1 A 1 B 1 C 1 | 1 D 1 E 1 F 1 | 1 G 1 H 1 I 1 ) 0 X 0'
GROUP='0 ( 1 A 1 B 1 C 1 | 1 D 1 E 1 F 1 | 1 G 1 H 1 I 1 ) 0 X 0'
STATE='0 ( 0 A 2 B 3 C 1 | 0 D 4 E 5 F 1 | 0 G 6 H 7 I 1 ) 1 X 8'
RULES='0:A -> 2
2:B -> 3
3:C -> 1
0:D -> 4
4:E -> 5
5:F -> 1
0:G -> 6
6:H -> 7
7:I -> 1
1:X -> 8'
parse $INPUT; RETVAL="$?"                      # intentionally unquoted
test 'Return value'     "0"      "$RETVAL"
test 'Bracket level'    "$LEVEL" "$_DEBUG_LEVEL" "$INPUT"
test 'Group numbers'    "$GROUP" "$_DEBUG_GROUP" "$INPUT"
test 'State numbers'    "$STATE" "$_DEBUG_STATE" "$INPUT"
test 'Rules'            "$RULES" "$_DEBUG_RULES" "$INPUT"

INPUT='  [   A   B   C   |   D   E   F   |   G   H   I   ]   X'
LEVEL='0 [ 1 A 1 B 1 C 1 | 1 D 1 E 1 F 1 | 1 G 1 H 1 I 1 ] 0 X 0'
GROUP='0 [ 1 A 1 B 1 C 1 | 1 D 1 E 1 F 1 | 1 G 1 H 1 I 1 ] 0 X 0'
STATE='0 [ 0 A 2 B 3 C 1 | 0 D 4 E 5 F 1 | 0 G 6 H 7 I 1 ] 1 X 8'
## FIXME: These rules should also account for the [...]
RULES='0:A -> 2
2:B -> 3
3:C -> 1
0:D -> 4
4:E -> 5
5:F -> 1
0:G -> 6
6:H -> 7
7:I -> 1
1:X -> 8'
parse $INPUT; RETVAL="$?"                      # intentionally unquoted
test 'Return value'     "0"      "$RETVAL"
test 'Bracket level'    "$LEVEL" "$_DEBUG_LEVEL" "$INPUT"
test 'Group numbers'    "$GROUP" "$_DEBUG_GROUP" "$INPUT"
test 'State numbers'    "$STATE" "$_DEBUG_STATE" "$INPUT"
test 'Rules'            "$RULES" "$_DEBUG_RULES" "$INPUT"

INPUT='  [   A   B   C   |   D   E   F   |   G   H   I   ]   ...  X'
LEVEL='0 [ 1 A 1 B 1 C 1 | 1 D 1 E 1 F 1 | 1 G 1 H 1 I 1 ] 0 ... 0 X 0'
GROUP='0 [ 1 A 1 B 1 C 1 | 1 D 1 E 1 F 1 | 1 G 1 H 1 I 1 ] 0 ... 0 X 0'
STATE='0 [ 0 A 2 B 3 C 1 | 0 D 4 E 5 F 1 | 0 G 6 H 7 I 1 ] 1 ... 1 X 8'
## FIXME: These rules should also account for the [...]
## Ellipsis is corresponds to rules: '1:A -> 2', '1:D -> 4' and '1:G -> 6'.
unset X                                        # ugly in-string coments
RULES="0:A -> 2
2:B -> 3
3:C -> 1
0:D -> 4
4:E -> 5
5:F -> 1
0:G -> 6
6:H -> 7
7:I -> 1
1:A -> 2${X:+                                  # ellipsis rule}
1:D -> 4${X:+                                  # ellipsis rule}
1:G -> 6${X:+                                  # ellipsis rule}
1:X -> 8"
parse $INPUT; RETVAL="$?"                      # intentionally unquoted
test 'Return value'     "0"      "$RETVAL"
test 'Bracket level'    "$LEVEL" "$_DEBUG_LEVEL" "$INPUT"
test 'Group numbers'    "$GROUP" "$_DEBUG_GROUP" "$INPUT"
test 'State numbers'    "$STATE" "$_DEBUG_STATE" "$INPUT"
test 'Rules'            "$RULES" "$_DEBUG_RULES" "$INPUT"

INPUT='  (   A   )'
LEVEL='0 ( 1 A 1 ) 0'
GROUP='0 ( 1 A 1 ) 0'
STATE='0 ( 0 A 1 ) 1'; FINAL="1"
RULES='0:A -> 1'
parse $INPUT; RETVAL="$?"                      # intentionally unquoted
test 'Return value'     "0"      "$RETVAL"
test 'Bracket level'    "$LEVEL" "$_DEBUG_LEVEL" "$INPUT"
test 'Group numbers'    "$GROUP" "$_DEBUG_GROUP" "$INPUT"
test 'States'           "$STATE" "$_DEBUG_STATE" "$INPUT"
test 'Rules'            "$RULES" "$_DEBUG_RULES" "$INPUT"

INPUT='  (   A   )   (   B   )'
LEVEL='0 ( 1 A 1 ) 0 ( 1 B 1 ) 0'
GROUP='0 ( 1 A 1 ) 0 ( 2 B 2 ) 0'
STATE='0 ( 0 A 1 ) 1 ( 1 B 2 ) 2'; FINAL="2"
RULES='0:A -> 1
1:B -> 2'
parse $INPUT; RETVAL="$?"                      # intentionally unquoted
test 'Return value'     "0"      "$RETVAL"
test 'Bracket level'    "$LEVEL" "$_DEBUG_LEVEL" "$INPUT"
test 'Group numbers'    "$GROUP" "$_DEBUG_GROUP" "$INPUT"
test 'States'           "$STATE" "$_DEBUG_STATE" "$INPUT"
test 'Rules'            "$RULES" "$_DEBUG_RULES" "$INPUT"

INPUT='  (   A   (   B   )   )'
LEVEL='0 ( 1 A 1 ( 2 B 2 ) 1 ) 0'
GROUP='0 ( 1 A 1 ( 2 B 2 ) 1 ) 0'
STATE='0 ( 0 A 2 ( 2 B 3 ) 3 ) 3'; FINAL="2"
RULES='0:A -> 2
2:B -> 3'
parse $INPUT; RETVAL="$?"                      # intentionally unquoted
test 'Return value'     "0"      "$RETVAL"
test 'Bracket level'    "$LEVEL" "$_DEBUG_LEVEL" "$INPUT"
test 'Group numbers'    "$GROUP" "$_DEBUG_GROUP" "$INPUT"
test 'States'           "$STATE" "$_DEBUG_STATE" "$INPUT"
test 'Rules'            "$RULES" "$_DEBUG_RULES" "$INPUT"

INPUT='  (   (   A   B   )   )'
LEVEL='0 ( 1 ( 2 A 2 B 2 ) 1 ) 0'
GROUP='0 ( 1 ( 2 A 2 B 2 ) 1 ) 0'
STATE='0 ( 0 ( 0 A 3 B 2 ) 2 ) 2'; FINAL="2"
RULES='0:A -> 3
3:B -> 2'
parse $INPUT; RETVAL="$?"                      # intentionally unquoted
test 'Return value'     "0"      "$RETVAL"
test 'Bracket level'    "$LEVEL" "$_DEBUG_LEVEL" "$INPUT"
test 'Group numbers'    "$GROUP" "$_DEBUG_GROUP" "$INPUT"
test 'States'           "$STATE" "$_DEBUG_STATE" "$INPUT"
test 'Rules'            "$RULES" "$_DEBUG_RULES" "$INPUT"

INPUT='  (   (   A   )   B   )'
LEVEL='0 ( 1 ( 2 A 2 ) 1 B 1 ) 0'
GROUP='0 ( 1 ( 2 A 2 ) 1 B 1 ) 0'
STATE='0 ( 0 ( 0 A 2 ) 2 B 1 ) 1'; FINAL="2"
RULES='0:A -> 2
2:B -> 1'
parse $INPUT; RETVAL="$?"                      # intentionally unquoted
test 'Return value'     "0"      "$RETVAL"
test 'Bracket level'    "$LEVEL" "$_DEBUG_LEVEL" "$INPUT"
test 'Group numbers'    "$GROUP" "$_DEBUG_GROUP" "$INPUT"
test 'States'           "$STATE" "$_DEBUG_STATE" "$INPUT"
test 'Rules'            "$RULES" "$_DEBUG_RULES" "$INPUT"

INPUT='  [   A   ]'
LEVEL='0 [ 1 A 1 ] 0'
GROUP='0 [ 1 A 1 ] 0'
STATE='0 [ 0 A 1 ] 1'; FINAL="0 1"
## FIXME: These rules should also account for the [...]
RULES='0:A -> 1'
parse $INPUT; RETVAL="$?"                      # intentionally unquoted
test 'Return value'     "0"      "$RETVAL"
test 'Bracket level'    "$LEVEL" "$_DEBUG_LEVEL" "$INPUT"
test 'Group numbers'    "$GROUP" "$_DEBUG_GROUP" "$INPUT"
test 'States'           "$STATE" "$_DEBUG_STATE" "$INPUT"
test 'Rules'            "$RULES" "$_DEBUG_RULES" "$INPUT"

INPUT='  (   A   |   B   )'
LEVEL='0 ( 1 A 1 | 1 B 1 ) 0'
GROUP='0 ( 1 A 1 | 1 B 1 ) 0'
STATE='0 ( 0 A 1 | 0 B 1 ) 1'; FINAL=1
RULES='0:A -> 1
0:B -> 1'
parse $INPUT; RETVAL="$?"                      # intentionally unquoted
test 'Return value'     "0"      "$RETVAL"
test 'Bracket level'    "$LEVEL" "$_DEBUG_LEVEL" "$INPUT"
test 'Group numbers'    "$GROUP" "$_DEBUG_GROUP" "$INPUT"
test 'States'           "$STATE" "$_DEBUG_STATE" "$INPUT"
test 'Rules'            "$RULES" "$_DEBUG_RULES" "$INPUT"

INPUT='  A ... B'
LEVEL='0 A 0 ... 0 B 0'
GROUP='0 A 0 ... 0 B 0'
STATE='0 A 1 ... 1 B 2'; FINAL=2
RULES='0:A -> 1
1:B -> 2'
parse $INPUT; RETVAL="$?"                      # intentionally unquoted
test 'Return value'     "0"      "$RETVAL"
test 'Bracket level'    "$LEVEL" "$_DEBUG_LEVEL" "$INPUT"
test 'Group numbers'    "$GROUP" "$_DEBUG_GROUP" "$INPUT"
test 'States'           "$STATE" "$_DEBUG_STATE" "$INPUT"
test 'Rules'            "$RULES" "$_DEBUG_RULES" "$INPUT"

## FIXME: NAKED ELLIPSIS (without preceeding parenthesis group)
# INPUT='  A   ...   B'
# LEVEL='0 A 0 ... 0 B 0'
# GROUP='0 A 0 ... 0 B 0'
# STATE='0 A 1 ... 1 B 2'; FINAL=2
# RULES='0:A -> 1
# 1:B -> 2
# 1:A -> 1'
# parse $INPUT; RETVAL="$?"                      # intentionally unquoted
# test 'Return value'     "0"      "$RETVAL"
# test 'Bracket level'    "$LEVEL" "$_DEBUG_LEVEL" "$INPUT"
# test 'Group numbers'    "$GROUP" "$_DEBUG_GROUP" "$INPUT"
# test 'States'           "$STATE" "$_DEBUG_STATE" "$INPUT"
# test 'Rules'            "$RULES" "$_DEBUG_RULES" "$INPUT"

INPUT='  (   A   ) ... B'
LEVEL='0 ( 1 A 1 ) 0 ... 0 B 0'
GROUP='0 ( 1 A 1 ) 0 ... 0 B 0'
STATE='0 ( 0 A 1 ) 1 ... 1 B 2'; FINAL=2
RULES='0:A -> 1
1:A -> 1
1:B -> 2'
parse $INPUT; RETVAL="$?"                      # intentionally unquoted
test 'Return value'     "0"      "$RETVAL"
test 'Bracket level'    "$LEVEL" "$_DEBUG_LEVEL" "$INPUT"
test 'Group numbers'    "$GROUP" "$_DEBUG_GROUP" "$INPUT"
test 'States'           "$STATE" "$_DEBUG_STATE" "$INPUT"
test 'Rules'            "$RULES" "$_DEBUG_RULES" "$INPUT"

INPUT='  (   A   B   )   ...'
LEVEL='0 ( 1 A 1 B 1 ) 0 ... 0'
GROUP='0 ( 1 A 1 B 1 ) 0 ... 0'
STATE='0 ( 0 A 2 B 1 ) 1 ... 1'; FINAL=2
RULES='0:A -> 2
2:B -> 1
1:A -> 2'
parse $INPUT; RETVAL="$?"                      # intentionally unquoted
test 'Return value'     "0"      "$RETVAL"
test 'Bracket level'    "$LEVEL" "$_DEBUG_LEVEL" "$INPUT"
test 'Group numbers'    "$GROUP" "$_DEBUG_GROUP" "$INPUT"
test 'States'           "$STATE" "$_DEBUG_STATE" "$INPUT"
test 'Rules'            "$RULES" "$_DEBUG_RULES" "$INPUT"

INPUT='  (   A   )   (   B   )   ...'
LEVEL='0 ( 1 A 1 ) 0 ( 1 B 1 ) 0 ... 0'
GROUP='0 ( 1 A 1 ) 0 ( 2 B 2 ) 0 ... 0'
STATE='0 ( 0 A 1 ) 1 ( 1 B 2 ) 2 ... 2'; FINAL=2
RULES='0:A -> 1
1:B -> 2
2:B -> 2'
parse $INPUT; RETVAL="$?"                      # intentionally unquoted
test 'Return value'     "0"      "$RETVAL"
test 'Bracket level'    "$LEVEL" "$_DEBUG_LEVEL" "$INPUT"
test 'Group numbers'    "$GROUP" "$_DEBUG_GROUP" "$INPUT"
test 'States'           "$STATE" "$_DEBUG_STATE" "$INPUT"
test 'Rules'            "$RULES" "$_DEBUG_RULES" "$INPUT"

# FIXME: Since state '1' was eaten here, the last rule output
# FIXME: When we have a case of multiple endings ) )... we must update END$IN for those groups
# FIXME: Implement rules here
INPUT='  (   A   (   B   )   )   ...'
LEVEL='0 ( 1 A 1 ( 2 B 2 ) 1 ) 0 ... 0'
GROUP='0 ( 1 A 1 ( 2 B 2 ) 1 ) 0 ... 0'
STATE='0 ( 0 A 2 ( 2 B 3 ) 3 ) 3 ... 3'; FINAL=3
RULES='0:A -> 2
2:B -> 3
3:A -> 2'
parse $INPUT; RETVAL="$?"                      # intentionally unquoted
test 'Return value'     "0"      "$RETVAL"
test 'Bracket level'    "$LEVEL" "$_DEBUG_LEVEL" "$INPUT"
test 'Group numbers'    "$GROUP" "$_DEBUG_GROUP" "$INPUT"
test 'States'           "$STATE" "$_DEBUG_STATE" "$INPUT"
#test 'Rules'            "$RULES" "$_DEBUG_RULES" "$INPUT"

# FIXME: Since state '1' was eaten here, the last rule output
# FIXME: when we have a case of multiple endings ) )... we must update END$IN for those groups
# FIXME: Implement rules here
INPUT='  (   A   (   B   (   C   )   )   )   ...'
LEVEL='0 ( 1 A 1 ( 2 B 2 ( 3 C 3 ) 2 ) 1 ) 0 ... 0'
GROUP='0 ( 1 A 1 ( 2 B 2 ( 3 C 3 ) 2 ) 1 ) 0 ... 0'
STATE='0 ( 0 A 2 ( 2 B 4 ( 4 C 5 ) 5 ) 5 ) 5 ... 5'; FINAL=5
RULES='0:A -> 2
2:B -> 4
4:C -> 5
5:A -> 2'
parse $INPUT; RETVAL="$?"                      # intentionally unquoted
test 'Return value'     "0"      "$RETVAL"
test 'Bracket level'    "$LEVEL" "$_DEBUG_LEVEL" "$INPUT"
test 'Group numbers'    "$GROUP" "$_DEBUG_GROUP" "$INPUT"
test 'States'           "$STATE" "$_DEBUG_STATE" "$INPUT"
test 'Rules'            "$RULES" "$_DEBUG_RULES" "$INPUT"

# FIXME: Since state '1' was eaten here, the last rule output
# FIXME: when we have a case of multiple endings ) )... we must update END$IN for those groups
# FIXME: Implement rules here
INPUT='  (   (   A   )   B   )   ...'
LEVEL='0 ( 1 ( 2 A 2 ) 1 B 1 ) 0 ... 0'
GROUP='0 ( 1 ( 2 A 2 ) 1 B 1 ) 0 ... 0'
STATE='0 ( 0 ( 0 A 2 ) 2 B 1 ) 1 ... 1'; FINAL=1
RULES='0:A -> 2
2:B -> 1
1:A -> 2'
parse $INPUT; RETVAL="$?"                      # intentionally unquoted
test 'Return value'     "0"      "$RETVAL"
test 'Bracket level'    "$LEVEL" "$_DEBUG_LEVEL" "$INPUT"
test 'Group numbers'    "$GROUP" "$_DEBUG_GROUP" "$INPUT"
test 'States'           "$STATE" "$_DEBUG_STATE" "$INPUT"
test 'Rules'            "$RULES" "$_DEBUG_RULES" "$INPUT"

## FIXME: Add test cases for
##     ( ( A ) B ) ...

######################################################################
##
##  Tests from Finite State Automaton Images
##

INPUT='  (   A   B   C   |   D   E   F   |   G   H   I   )'
LEVEL='0 ( 1 A 1 B 1 C 1 | 1 D 1 E 1 F 1 | 1 G 1 H 1 I 1 ) 0'
GROUP='0 ( 1 A 1 B 1 C 1 | 1 D 1 E 1 F 1 | 1 G 1 H 1 I 1 ) 0'
STATE='0 ( 0 A 2 B 3 C 1 | 0 D 4 E 5 F 1 | 0 G 6 H 7 I 1 ) 1'; FINAL=1
RULES='0:A -> 2
2:B -> 3
3:C -> 1
0:D -> 4
4:E -> 5
5:F -> 1
0:G -> 6
6:H -> 7
7:I -> 1'
#1: -> X'                                      # FIXME: eol (or next grouping)
# FIXME: Code should produce the (above) finishing state
parse $INPUT; RETVAL="$?"                      # intentionally unquoted
test 'Return value'     "0"      "$RETVAL"
test 'Bracket level'    "$LEVEL" "$_DEBUG_LEVEL" "$INPUT"
test 'Group numbers'    "$GROUP" "$_DEBUG_GROUP" "$INPUT"
test 'States'           "$STATE" "$_DEBUG_STATE" "$INPUT"
test 'Rules'            "$RULES" "$_DEBUG_RULES" "$INPUT"

INPUT='  [   A   B   C   |   D   E   F   |   G   H   I   ]'
LEVEL='0 [ 1 A 1 B 1 C 1 | 1 D 1 E 1 F 1 | 1 G 1 H 1 I 1 ] 0'
GROUP='0 [ 1 A 1 B 1 C 1 | 1 D 1 E 1 F 1 | 1 G 1 H 1 I 1 ] 0'
STATE='0 [ 0 A 2 B 3 C 1 | 0 D 4 E 5 F 1 | 0 G 6 H 7 I 1 ] 1'; FINAL="0 1"
RULES='0:A -> 2
2:B -> 3
3:C -> 1
0:D -> 4
4:E -> 5
5:F -> 1
0:G -> 6
6:H -> 7
7:I -> 1'
#1: -> X                                       # FIXME: eol (or next grouping)
#0: -> X'                                      # FIXME: eol (or next grouping)
# FIXME: Code should produce the (above) finishing states
parse $INPUT; RETVAL="$?"                      # intentionally unquoted
test 'Return value'     "0"      "$RETVAL"
test 'Bracket level'    "$LEVEL" "$_DEBUG_LEVEL" "$INPUT"
test 'Group numbers'    "$GROUP" "$_DEBUG_GROUP" "$INPUT"
test 'States'           "$STATE" "$_DEBUG_STATE" "$INPUT"
test 'Rules'            "$RULES" "$_DEBUG_RULES" "$INPUT"

INPUT='  (   A   B   C   |   D   E   F   |   G   H   I   )   ...'
LEVEL='0 ( 1 A 1 B 1 C 1 | 1 D 1 E 1 F 1 | 1 G 1 H 1 I 1 ) 0 ... 0'
GROUP='0 ( 1 A 1 B 1 C 1 | 1 D 1 E 1 F 1 | 1 G 1 H 1 I 1 ) 0 ... 0'
STATE='0 ( 0 A 2 B 3 C 1 | 0 D 4 E 5 F 1 | 0 G 6 H 7 I 1 ) 1 ... 1'; FINAL=1
unset X                                        # ugly in-string coments
RULES="0:A -> 2
2:B -> 3
3:C -> 1
0:D -> 4
4:E -> 5
5:F -> 1
0:G -> 6
6:H -> 7
7:I -> 1
1:A -> 2${X:+                                  # ellipsis rule}
1:D -> 4${X:+                                  # ellipsis rule}
1:G -> 6${X:+                                  # ellipsis rule}"
#1: -> X'                                      # FIXME: eol (or next grouping)
# FIXME: Code should produce the (above) finishing state
parse $INPUT; RETVAL="$?"                      # intentionally unquoted
test 'Return value'     "0"      "$RETVAL"
test 'Bracket level'    "$LEVEL" "$_DEBUG_LEVEL" "$INPUT"
test 'Group numbers'    "$GROUP" "$_DEBUG_GROUP" "$INPUT"
test 'States'           "$STATE" "$_DEBUG_STATE" "$INPUT"
test 'Rules'            "$RULES" "$_DEBUG_RULES" "$INPUT"

INPUT='  [   A   B   C   |   D   E   F   |   G   H   I   ] ...'
LEVEL='0 [ 1 A 1 B 1 C 1 | 1 D 1 E 1 F 1 | 1 G 1 H 1 I 1 ] 0 ... 0'
GROUP='0 [ 1 A 1 B 1 C 1 | 1 D 1 E 1 F 1 | 1 G 1 H 1 I 1 ] 0 ... 0'
STATE='0 [ 0 A 2 B 3 C 1 | 0 D 4 E 5 F 1 | 0 G 6 H 7 I 1 ] 1 ... 1'; FINAL="0 1"
unset X                                        # ugly in-string coments
RULES="0:A -> 2
2:B -> 3
3:C -> 1
0:D -> 4
4:E -> 5
5:F -> 1
0:G -> 6
6:H -> 7
7:I -> 1
1:A -> 2${X:+                                  # ellipsis rule}
1:D -> 4${X:+                                  # ellipsis rule}
1:G -> 6${X:+                                  # ellipsis rule}"
#1: -> X                                       # FIXME: eol (or next grouping)
#0: -> X'                                      # FIXME: eol (or next grouping)
# FIXME: Code should produce the (above) finishing state
BEGENV="$(dumpenv \
    _DEBUG_RULES _DEBUG_STATE _DEBUG_GROUP _DEBUG_LEVEL \
    BEGENV ENDENV TESTS_COUNT FAILED_TESTS TMPNUM)" # expect
parse $INPUT; RETVAL="$?"                      # intentionally unquoted
test 'Return value'     "0"      "$RETVAL"
test 'Bracket level'    "$LEVEL" "$_DEBUG_LEVEL" "$INPUT"
test 'Group numbers'    "$GROUP" "$_DEBUG_GROUP" "$INPUT"
test 'States'           "$STATE" "$_DEBUG_STATE" "$INPUT"
test 'Rules'            "$RULES" "$_DEBUG_RULES" "$INPUT"
ENDENV="$(dumpenv \
    _DEBUG_RULES _DEBUG_STATE _DEBUG_GROUP _DEBUG_LEVEL \
    BEGENV ENDENV TESTS_COUNT FAILED_TESTS TMPNUM)" # got
test 'Variable leakage' "$BEGENV" "$ENDENV"      "$INPUT"

done_testing
exit


    ARGS='  [ NAME ]'
EXPECTED='0 [ 0 NAME 0 ] 0'
out $ARGS           # intentionally unquoted
parse $ARGS      # intentionally unquoted

    ARGS='  (   (   A   (   B   |   C   [   D   ]   )   )   |   (   E   )   (   F   )   )'
EXPECTED='0 ( 0 ( 0 A 1 ( 1 B 2 | 1 C 3 [ 3 D 3 ] 3 ) 3 ) 3 | 0 ( 0 E 4 ) 4 ( 4 F 5 ) 5 ) 5'
#         0 ( 0 ( 0   1 ( 1   2 | 1   3 [ 3   3 ] 3 ) 3 ) 3 | 0 ( 0   4 ) 4 ( 4   5 ) 5 ) 5
# LEVEL:    1   2   2   3   3   3   3   4   4   4   3   2   1   2   2   2   2   2   2   1
# START:    0   0       1               3                       2       2   2       2   1

# before '|' = set group endstate
#   if type bracket = endstate = startstate
#   if type paren   = endstate = next state


out $ARGS        # intentionally unquoted
parse $ARGS   # intentionally unquoted

echo ">$BEG2<"

#[eof]

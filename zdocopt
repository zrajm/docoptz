#!/bin/sh

# -e -- errexit mode. Interrupt script if any command has exit code >0, unless
# caught. The tests run with '&& :' which suppresses this for a single command,
# while still catching the exit value in '$?'.
set -e

# set -euv

# SOONER
# ======
# FIXME: Implement [...] some leading and final rules will be needed twice: Implement!
# FIXME: Implement finishing rules (instead of final states)

# LATER
# =====
# FIXME: Write tokenizer function
# FIXME: Multiple passes of parse, building up a grammar?
# FIXME: Allow 'xxx|yyy' (without parentheses)
# FIXME: Stop using $IN and $GROUP? (if possible)
# FIXME: Remove dead code

#DEBUG=1
DEBUG="${DEBUG:-}"
if [ "$DEBUG" ]; then
    DEBUG() { {
        printf '%s\n' "$1"; shift
        printf '    %s\n' "$@"
    } >&2; }
else
    DEBUG() { :; }
fi

################################################################################

out() { printf '%s\n' "$*"; }
#die() { warn "$@"; exit 5; }
warn() {
    [ "$1" ] && out "${0##*/}: $1" >&2
    [ "$2" ] && out "$2" >&2
    return 0
}

ok_varname() {
    local H V
    case "$1" in *[!A-Z0-9_]*|[0-9]*)
        warn "${2:+$2: }Bad variable name '$1'"
        return 1
    esac
    return 0
}

# Usage: VARNAME PREFIX STRING
#
# Prefix every line in STRING with PREFIX, return in VARNAME.
prefix() {
    local _VAR="$1" _PRE="$2" _ARG='' IFS='
'                                              # intentional newline
    ok_varname "$_VAR" prefix || return 1      # verify VARNAME
    set -- $3                                  # intentionally unquoted
    for _ARG in "$@"; do
        shift
        set "$@" "$_PRE$_ARG"
    done
    eval "$_VAR"="\$*"
}

# Usage: append VARNAME STRING
#
# Append STRING to VARNAME with a space inbetween (unless VARNAME is empty, in
# which case no space is inserted in front of STRING).
append() {
    ok_varname "$1" append || return 1
    # VARNAME="${VARNAME:+$VARNAME }$2"
    eval "$1=\"\${$1:+\$$1 }\$2\""
}

# Usage: appendnl VARNAME STRING
#
# Append STRING to VARNAME with a space inbetween (unless VARNAME is empty, in
# which case no space is inserted in front of STRING).
appendnl() {
    ok_varname "$1" appendnl || return 1
    # VARNAME="${VARNAME:+$VARNAME<NEWLINE>}$2"
    eval "$1=\"\${$1:+\$$1
}\$2\""                                        # intentional newline
}

# Usage: getvar VARNAME1 VARNAME2
#
# Set VARNAME1 to whatever variable VARNAME2 contains.
getvar() { eval "$1=\"\$$2\""; }

# Usage: setvar VARNAME VALUE
#
# Set variable VARNAME to the specified value.
setvar() { eval "$1=\"\$2\""; }

# Usage: incvar VARNAME
#
# Sets variable VARNAME to 0 if unset, otherwise increment VARNAME by one.
incvar() { eval "$1=\"\$((\${$1:--1} + 1))\""; } #VAR="$((${VAR:--1} + 1))"

# Usage: decvar VARNAME
#
# Sets variable VARNAME to 0 if unset, otherwise decrement VARNAME by one.
decvar() { setvar "$1" "$(($1 - 1))"; }

# Usage: match PATTERN STRING
#
# Return true if PATTERN was found in STRING, false otherwise. PATTERN is
# evaluated using a shell case statement. Since PATTERN is inserted into an
# eval a non-verified PATTERN from a user can be a HUGE security problem, so
# make sure your PATTERN is properly vetted, or better yet, a string literal.
match() {
    eval "case \"\$2\" in ($1) return 0; esac"
    return 1
}

# Usage: eqvar VARNAME1 VARNAME2
#
# Returns true (0) if variables VARNAME1 and VARNAME2 have identical content,
# otherwise return false (1).
eqvar() {
    ok_varname "$1" eqvar || return 1
    ok_varname "$2" eqvar || return 1
    local A B
    getvar A "$1"
    getvar B "$2"
    [ "$A" = "$B" ]
}

# Usage: parse RULESVAR TOKENIZED
#
# Go through TOKENIZED and create finite-state machine rules suitable for
# parsing a command line. Also checks the validity/nesting of (...) and [...]
# constructs. (Failing if brackets or parentheses are unbalanced.)
#
# The generated rules will be saved in the specified RULESVAR. Each rule is
# separated by an newline, and is of the format 'STATE:INPUT -> ENDSTATE', or
# just 'ENDSTATE'.
#
# The following special characters are recognized:
#   * Group start: '[' or '('
#   * Group end: ']' or ')'
#   * Subgroup separator: '|'
#   * Group repeat: '...'
#
# The beginning of a subgroup can be attached to one or more states (if the
# previous subgroup[s] where optional). The first part of each subgroup is
# therefore connected to all the STARTAT states (space-separated list state
# identifiers). The remaining group states should be the same regardless of
# which 'entry' was taken.
#
# Internals:
#
# LVL is the current level of nesting. GROUPS in the number of the current
# parenthesis. In '()()' GROUPS is 1 and 2, and LVL 0 and 1. In '(())' GROUPS
# is also 1 & 2, but LVL is 0 (outside paren), 1 (inside first paren), and 2
# (inside innermost paren). I.e. GROUPS never decreases, while LVL does. IN is
# the current group we're in, so in '()()' it looks like this '0(1)0(2)0',
# while in '(())' its '0(1(2)1)0'.

#
# GROUP0...N is a pseudo-array containing group stack. It has no meaning
# outside this loop. It contains the group number of the current parenthetical
# group at the end.
#
# TYPE0...N is pseudo-array containing group type. TYPE0='' (because its not
# within brackets), all higher numbers are either ']' or ')' depending on
# whether it's a [...] or (...) group.
#

# ELLIPSIS RULES (_ELL<$LVL>)
# ===========================
# Ellipsis rules are extra rules built up during the processing of each
# parenthesis/bracket group, which are only inserted into the final ruleset if
# the group in question is followed by '...' (if not used, then the ellipsis
# rules are forgotten upon exiting the group). In the Finate State Automaton
# images, these are the lines marked in purple (which allow for repetition of a
# group).
#
# FINAL STATES
# ============
# Accumulate final states FINAL$IN. Whenever a new group is started on the same
# level, and after the one which registered its final states, then the final
# states should be removed, and instead a set of rules for transitioning from
# the previously final state into the new group should be created. (And we
# continue to accumulate new final state names.)
#
# Upon reaching the end of the input string, check to make sure were in one of
# the final states.

# STATE is the currently processed state, STATEMAX is the maxiumum state used
# so far (for each state added STATEMAX is increased, so that it is the highest
# STATE used so far).
parse() {
    ok_varname "$1" parse || return 1
    local _VAR="$1"; shift
    _DEBUG_STATE=''                            # used in testing
    _DEBUG_GROUP=''
    _DEBUG_LEVEL=''
    local _STATE=0 _STATEMAX=0
    local _RULES='' _FINAL=''
    local _GRPMAX=0 _LVL=0 _IN=0               # group count + level, current group
    local _BEG0=0 _END0=0 _GRP0=0 TYPE0=''     # loop stacks
    # Loop over $@ while setting $A to current arg, and $NEXT to next arg.
    local I=0 A='' NEXT='' PREV=''
    while I="$(( I + 1 ))"; [ "$I" -le "$#" ]; do
        eval    A="\"\$$I\""                   # current arg
        eval NEXT="\"\$$(( I + 1 ))\""         #   next arg
        append _DEBUG_STATE "$_STATE $A" || return 1
        append _DEBUG_GROUP "$_IN $A"    || return 1
        append _DEBUG_LEVEL "$_LVL $A"   || return 1
        case "$A" in
            ['(['])                            # start parenthesis or bracket
                incvar _LVL                    #   level (paren depth)
                incvar _GRPMAX                 #   group (paren number)
                incvar _STATEMAX               #   state counter
                _IN="$_GRPMAX"                 #   current group
                local "_BEG$_LVL"="$_STATE"    #     stack: group start state
                local "_END$_LVL"="$_STATEMAX" #     stack: group end state
                local "_GRP$_LVL"="$_GRPMAX"   #     stack: group number
                local "_ELL$_LVL"=""           #     stack: ellipsis rule
                case "$A" in                   #     stack: group type
                    '(') local "TYPE$_LVL"=')' ;;
                    '[') local "TYPE$_LVL"=']' ;;
                esac
                ;;
            '|')                               # pipe
                # FIXME: Should '||', '[|', '(|', '|]' and '|)' be allowed?
                if [ "$_LVL" -eq 0 ]; then
                    warn "Badly placed '|' in rule: $*" \
                         '(Must be within parentheses/brackets.)'
                    return 1
                fi
                getvar _STATE "_BEG$_LVL"      #   return to group start state
                ;;
            ['])'])                            # end bracket
                local TYPE; getvar TYPE "TYPE$_LVL"
                [ "$_LVL" -le 0    ] && warn "Too many '$A' in rule: $*" && return 1
                [ "$A" != "$TYPE" ] && warn "Missing '$A' in rule (group $_IN): $*" && return 1
                unset TYPE

                #getvar _STATE "_END$_LVL"      #     return state to start bracket

                # Apply ellipsis rules if followed by '...'.
                if [ "$NEXT" = '...' ]; then
                    local _ELL; getvar _ELL "_ELL$_LVL"
                    local NEWRULES; prefix NEWRULES "$_STATE:" "$_ELL"
                    appendnl "_RULES" "$NEWRULES" || return 1
                    unset _ELL NEWRULES
                fi
                # Pop off last element of 'stack's.
                unset "_GRP$_LVL" "TYPE$_LVL" "_BEG$_LVL" "_END$_LVL" "_ELL$_LVL"
                decvar _LVL                    #   go down one level
                getvar _IN "_GRP$_LVL"         #   current group number
                # FIXME: These lines not covered by test cases!! (necessary?)
                case "$NEXT" in [')]'])
                    local "_END$_LVL"="$_STATE"
                esac
                ;;
            '...')                             # ellipsis
                ## This state only handles where an ellipsis is allowed. Actual
                ## ellipsis logic is ran in the end group state, and ARG state
                ## where al the needed variables are already set.
                if [ "$I" = 1 ] || match '["|(["]|...' "$PREV"; then
                    warn "Badly placed '...' in rule: $*" \
                         '(Must come after ARGUMENT or end parenthesis/bracket.)'
                    return 1
                fi
                ;;
            *)                                 # anything else
                local PREVSTATE="$_STATE" ENDSTATE=''
                case "$NEXT" in                #   last in bracket group
                    ['|)]'])                   #     use last state of bracket
                        getvar ENDSTATE "_END$_LVL"
                        _STATE="$ENDSTATE" ;;
                    *)                         #   otherwise
                        incvar _STATEMAX       #     increase state by one
                        _STATE="$_STATEMAX" ;;
                esac
                appendnl _RULES "$PREVSTATE:$A -> $_STATE" || return 1
                # If followed by '...' add rule to self.
                if [ "$NEXT" = '...' ]; then
                    appendnl _RULES "$_STATE:$A -> $_STATE" || return 1
                fi
                case "$PREV" in ['[(|'])       # add ellipsis rule
                    appendnl "_ELL$_LVL" "$A -> $_STATE" || return 1
                    # If this group and previous group start at same state (ie
                    # leading parenthesis is doubled, tripled etc) then copy
                    # ellipsis rules to previous group as well.
                    local _J="$_LVL"
                    while decvar _J && [ "$_J" -gt 0 ] && eqvar "_BEG$_LVL" "_BEG$_J"; do
                        appendnl "_ELL$_J" "$A -> $_STATE" || return 1
                    done
                esac
                ;;
        esac
        # # DEBUG: Indented parse output
        # local _DEBUG_INDENT _DEBUG_INDENT_NEXT
        # case "$A" in
        #     '('|'[')                           # start parenthesis or bracket
        #         _DEBUG_INDENT_NEXT="    $_DEBUG_INDENT" ;;
        #     ']'|')')                           # end bracket
        #         _DEBUG_INDENT="${_DEBUG_INDENT#    }"
        #         _DEBUG_INDENT_NEXT="$_DEBUG_INDENT" ;;
        #     '|')                               #   pipe
        #         _DEBUG_INDENT_NEXT="$_DEBUG_INDENT"
        #         _DEBUG_INDENT="${_DEBUG_INDENT#  }" ;;
        # esac
        # local TMP
        # getvar TMP "_ELL$_LVL"
        # out "${_DEBUG_INDENT}'$A'"
        # out "${_DEBUG_INDENT}    ((ELLIPSIS$_LVL: $TMP))"
        # #out "  ${_DEBUG_INDENT}LVL:$_LVL STATE:$_STATE"
        # _DEBUG_INDENT="$_DEBUG_INDENT_NEXT"
        PREV="$A"
    done
    unset "_GRP0"  # last element of group stack
    unset "TYPE0"
    append _DEBUG_STATE "$_STATE" || return 1
    append _DEBUG_GROUP "$_IN"    || return 1
    append _DEBUG_LEVEL "$_LVL"   || return 1

    if [ "$_LVL" -ne 0 ]; then
        local PAREN; getvar PAREN "TYPE$_LVL"
        warn "Missing '$PAREN' at end of rule: $*"
        return 1
    fi
    setvar "$_VAR" "$_RULES"
}

################################################################################
##                                                                            ##
##  Test "Framework"                                                          ##
##                                                                            ##
################################################################################

TESTS_DONE=''
TMPDIR="$(mktemp -dt zdocpt2-XXXXXX)"
TMPNUM="0"
BIN="${0##*/}"
trap "trapfunc \"$TMPDIR\"" EXIT INT

trapfunc() {
    local TMPDIR="$1"
    trap - EXIT INT
    [ -d '$TMPDIR' ] && rm -r '$TMPDIR'
    if [ -z "$TESTS_DONE" ]; then
       out '***PREMATURE EXIT! Not all tests ran!'
       printf '==============================================\n'
       printf '== %-40s ==\n' 'ABORTED EXECUTION!!!!!!!!!!!!11111!!!'
       printf '== %-40s ==\n' "Ran $TESTS_COUNT tests before exiting."
       printf '==============================================\n'
    fi
    exit 15
}

# Usage: tmpfile VARNAME
#
# Sets variable VARNAME to next suitable tempfile.
tmpfile() {
    ok_varname "$1" tmpfile || return 1
    setvar "$1" "$TMPDIR/$TMPNUM"
    incvar TMPNUM
}

FAILED_TESTS=0
TESTS_COUNT=0
# Usage: test GOT EXPECTED [MESSAGE]
#
# Tests if GOT and EXPECTED is the same, return true if this is the case, false
# otherwise. When returning false, also output a descriptive error message on
# standard output describing the difference between GOT and EXPECTED.
test() {
    local GOT="$1" EXPECTED="$2" MSG="$3"
    TESTS_COUNT="$(( TESTS_COUNT + 1 ))"
    if [ "$GOT" != "$EXPECTED" ]; then
        out "Test failed!!!"
        out "    $MSG"
        local FILE1='' FILE2=''; tmpfile FILE1; tmpfile FILE2
        { out 'EXPECTED:'; out "$EXPECTED"; } >"$FILE1"
        { out 'GOT:';      out "$GOT";      } >"$FILE2"
        local WIDTH="$(( $(wc -L <"$FILE1") + $(wc -L <"$FILE2") + 8 ))"
        [ "$WIDTH" -gt "$COLUMNS" ] && WIDTH="$COLUMNS"
        diff --width="$WIDTH" --color=always --expand-tabs \
             --side-by-side "$FILE1" "$FILE2" | \
            while IFS='' read -r LINE; do echo "    $LINE\e[m"; done
        out '----------------------------------------'
        #printfnl '    EXPECTED: %s' '              %s' "$EXPECTED"
        #printfnl '     BUT GOT: %s' '              %s' "$GOT"
        FAILED_TESTS="$(( FAILED_TESTS + 1 ))"
        return 1
    fi
    return 0
}

done_testing() {
    TESTS_DONE=1
    if [ "$FAILED_TESTS" -ne 0 ]; then
        printf '==============================================\n'
        printf '== %-40s ==\n' 'ERRORS!!!!!!!!!!!!11111!!!'
        printf '== %-40s ==\n' "$FAILED_TESTS (of $TESTS_COUNT) tests failed!"
        printf '==============================================\n'
        exit 10
    else
        printf "All %s tests passed.\n" "$TESTS_COUNT"
    fi
}

# Usage: dumpenv VARNAME...
#
# Outputs all environment variables to standard output (usin `set`) except
# those specified on the command line. All named variables are locally unset
# before outputting the variables but restored upon exiting the function.
dumpenv() {
    for VAR in "$@"; do
        local "$VAR"
        unset "$VAR"
    done
    set
}

# Usage: readall VARNAME [<FILE]
#
# Reads all of standard input sets the variable VARNAME to whatever was read.
# Each line read from standard input is separated by a newline, but no final
# trailing final trailing newline is added.
readall() {
    local _
    eval "$1"=''
    while IFS='' read -r _; do
        eval "$1"="\"\${$1:+\$$1
}\$_\""                                        # intentional newline
    done
}

################################################################################
##                                                                            ##
##  Tests                                                                     ##
##                                                                            ##
################################################################################

######################################################################
##
##  Test parse() error messages
##

## Badly placed '...' (at beginning)
INPUT='...'
tmpfile TMPFILE
parse GOTTED_RULES $INPUT 2>"$TMPFILE" && :; RETVAL="$?" # intentionally unquoted
readall ERRMSG <"$TMPFILE"
test "$RETVAL" '1'                                      'Return value'
test "$ERRMSG" "$BIN: Badly placed '...' in rule: ...
(Must come after ARGUMENT or end parenthesis/bracket.)" 'Error message'

## Badly placed '...' (after start parenthesis)
INPUT='( ...'
tmpfile TMPFILE
parse GOTTED_RULES $INPUT 2>"$TMPFILE" && :; RETVAL="$?" # intentionally unquoted
readall ERRMSG <"$TMPFILE"
test "$RETVAL" '1'                                      'Return value'
test "$ERRMSG" "$BIN: Badly placed '...' in rule: ( ...
(Must come after ARGUMENT or end parenthesis/bracket.)" 'Error message'

## Badly placed '|' (outside paren)
INPUT='|'
tmpfile TMPFILE
parse GOTTED_RULES $INPUT 2>"$TMPFILE" && :; RETVAL="$?" # intentionally unquoted
readall ERRMSG <"$TMPFILE"
test "$RETVAL" '1'                                     'Return value'
test "$ERRMSG" "$BIN: Badly placed '|' in rule: |
(Must be within parentheses/brackets.)"                'Error message'

## One ')' too many
INPUT='A )'
tmpfile TMPFILE
parse GOTTED_RULES $INPUT 2>"$TMPFILE" && :; RETVAL="$?" # intentionally unquoted
readall ERRMSG <"$TMPFILE"
test "$RETVAL" '1'                                     'Return value'
test "$ERRMSG" "$BIN: Too many ')' in rule: A )"       'Error message'

## One ']' too many
INPUT='A ]'
tmpfile TMPFILE
parse GOTTED_RULES $INPUT 2>"$TMPFILE" && :; RETVAL="$?" # intentionally unquoted
readall ERRMSG <"$TMPFILE"
test "$RETVAL" '1'                                     'Return value'
test "$ERRMSG" "$BIN: Too many ']' in rule: A ]"       'Error message'

## Missing ')'
INPUT='[ A )'
tmpfile TMPFILE
parse GOTTED_RULES $INPUT 2>"$TMPFILE" && :; RETVAL="$?" # intentionally unquoted
readall ERRMSG <"$TMPFILE"
test "$RETVAL" '1'                                     'Return value'
test "$ERRMSG" "$BIN: Missing ')' in rule (group 1): [ A )" 'Error message'

## Missing ']'
INPUT='( A ]'
tmpfile TMPFILE
parse GOTTED_RULES $INPUT 2>"$TMPFILE" && :; RETVAL="$?" # intentionally unquoted
readall ERRMSG <"$TMPFILE"
test "$RETVAL" '1'                                     'Return value'
test "$ERRMSG" "$BIN: Missing ']' in rule (group 1): ( A ]" 'Error message'

## Missing ']'
INPUT='( A'
tmpfile TMPFILE
parse GOTTED_RULES $INPUT 2>"$TMPFILE" && :; RETVAL="$?" # intentionally unquoted
readall ERRMSG <"$TMPFILE"
test "$RETVAL" '1'                                     'Return value'
test "$ERRMSG" "$BIN: Missing ')' at end of rule: ( A" 'Error message'

######################################################################
##
##  Test Actual Results
##

INPUT='  A'
LEVEL='0 A 0'
GROUP='0 A 0'
STATE='0 A 1'; FINAL='1'
RULES='0:A -> 1'
parse GOTTED_RULES $INPUT && :; RETVAL="$?"    # intentionally unquoted
test "$RETVAL"       '0'      'Return value'
test "$_DEBUG_LEVEL" "$LEVEL" "Bracket level: '$INPUT'"
test "$_DEBUG_GROUP" "$GROUP" "Group numbers: '$INPUT'"
test "$_DEBUG_STATE" "$STATE" "State numbers: '$INPUT'"
test "$GOTTED_RULES" "$RULES"         "Rules: '$INPUT'"

INPUT='  A   B'
LEVEL='0 A 0 B 0'
GROUP='0 A 0 B 0'
STATE='0 A 1 B 2'; FINAL='2'
RULES='0:A -> 1
1:B -> 2'
parse GOTTED_RULES $INPUT && :; RETVAL="$?"    # intentionally unquoted
test "$RETVAL"       '0'      'Return value'
test "$_DEBUG_LEVEL" "$LEVEL" "Bracket level: '$INPUT'"
test "$_DEBUG_GROUP" "$GROUP" "Group numbers: '$INPUT'"
test "$_DEBUG_STATE" "$STATE" "State numbers: '$INPUT'"
test "$GOTTED_RULES" "$RULES"         "Rules: '$INPUT'"

INPUT='  (   A   B   )'
LEVEL='0 ( 1 A 1 B 1 ) 0'
GROUP='0 ( 1 A 1 B 1 ) 0'
STATE='0 ( 0 A 2 B 1 ) 1'; FINAL='2'
RULES='0:A -> 2
2:B -> 1'
parse GOTTED_RULES $INPUT && :; RETVAL="$?"    # intentionally unquoted
test "$RETVAL"       '0'      'Return value'
test "$_DEBUG_LEVEL" "$LEVEL" "Bracket level: '$INPUT'"
test "$_DEBUG_GROUP" "$GROUP" "Group numbers: '$INPUT'"
test "$_DEBUG_STATE" "$STATE" "State numbers: '$INPUT'"
test "$GOTTED_RULES" "$RULES"         "Rules: '$INPUT'"

INPUT='  (   A   B   ) ...'
LEVEL='0 ( 1 A 1 B 1 ) 0 ... 0'
GROUP='0 ( 1 A 1 B 1 ) 0 ... 0'
STATE='0 ( 0 A 2 B 1 ) 1 ... 1'; FINAL='2'
RULES='0:A -> 2
2:B -> 1
1:A -> 2'
parse GOTTED_RULES $INPUT && :; RETVAL="$?"    # intentionally unquoted
test "$RETVAL"       '0'      'Return value'
test "$_DEBUG_LEVEL" "$LEVEL" "Bracket level: '$INPUT'"
test "$_DEBUG_GROUP" "$GROUP" "Group numbers: '$INPUT'"
test "$_DEBUG_STATE" "$STATE" "State numbers: '$INPUT'"
test "$GOTTED_RULES" "$RULES"         "Rules: '$INPUT'"

INPUT='  (   A   )   B'
LEVEL='0 ( 1 A 1 ) 0 B 0'
GROUP='0 ( 1 A 1 ) 0 B 0'
STATE='0 ( 0 A 1 ) 1 B 2'; FINAL='2'
RULES='0:A -> 1
1:B -> 2'
parse GOTTED_RULES $INPUT && :; RETVAL="$?"    # intentionally unquoted
test "$RETVAL"       '0'      'Return value'
test "$_DEBUG_LEVEL" "$LEVEL" "Bracket level: '$INPUT'"
test "$_DEBUG_GROUP" "$GROUP" "Group numbers: '$INPUT'"
test "$_DEBUG_STATE" "$STATE" "State numbers: '$INPUT'"
test "$GOTTED_RULES" "$RULES"         "Rules: '$INPUT'"

INPUT='  (   A   )   ...   B'
LEVEL='0 ( 1 A 1 ) 0 ... 0 B 0'
GROUP='0 ( 1 A 1 ) 0 ... 0 B 0'
STATE='0 ( 0 A 1 ) 1 ... 1 B 2'; FINAL='2'
RULES='0:A -> 1
1:A -> 1
1:B -> 2'
parse GOTTED_RULES $INPUT && :; RETVAL="$?"    # intentionally unquoted
test "$RETVAL"       '0'      'Return value'
test "$_DEBUG_LEVEL" "$LEVEL" "Bracket level: '$INPUT'"
test "$_DEBUG_GROUP" "$GROUP" "Group numbers: '$INPUT'"
test "$_DEBUG_STATE" "$STATE" "State numbers: '$INPUT'"
test "$GOTTED_RULES" "$RULES"         "Rules: '$INPUT'"

INPUT='  A   (   B   )'
LEVEL='0 A 0 ( 1 B 1 ) 0'
GROUP='0 A 0 ( 1 B 1 ) 0'
STATE='0 A 1 ( 1 B 2 ) 2'; FINAL='2'
RULES='0:A -> 1
1:B -> 2'
parse GOTTED_RULES $INPUT && :; RETVAL="$?"    # intentionally unquoted
test "$RETVAL"       '0'      'Return value'
test "$_DEBUG_LEVEL" "$LEVEL" "Bracket level: '$INPUT'"
test "$_DEBUG_GROUP" "$GROUP" "Group numbers: '$INPUT'"
test "$_DEBUG_STATE" "$STATE" "State numbers: '$INPUT'"
test "$GOTTED_RULES" "$RULES"         "Rules: '$INPUT'"

INPUT='  A   (   B   ) ...'
LEVEL='0 A 0 ( 1 B 1 ) 0 ... 0'
GROUP='0 A 0 ( 1 B 1 ) 0 ... 0'
STATE='0 A 1 ( 1 B 2 ) 2 ... 2'; FINAL='2'
RULES='0:A -> 1
1:B -> 2
2:B -> 2'
parse GOTTED_RULES $INPUT && :; RETVAL="$?"    # intentionally unquoted
test "$RETVAL"       '0'      'Return value'
test "$_DEBUG_LEVEL" "$LEVEL" "Bracket level: '$INPUT'"
test "$_DEBUG_GROUP" "$GROUP" "Group numbers: '$INPUT'"
test "$_DEBUG_STATE" "$STATE" "State numbers: '$INPUT'"
test "$GOTTED_RULES" "$RULES"         "Rules: '$INPUT'"

INPUT='  (   A   )   (   B   )'
LEVEL='0 ( 1 A 1 ) 0 ( 1 B 1 ) 0'
GROUP='0 ( 1 A 1 ) 0 ( 2 B 2 ) 0'
STATE='0 ( 0 A 1 ) 1 ( 1 B 2 ) 2'; FINAL='2'
RULES='0:A -> 1
1:B -> 2'
parse GOTTED_RULES $INPUT && :; RETVAL="$?"    # intentionally unquoted
test "$RETVAL"       '0'      'Return value'
test "$_DEBUG_LEVEL" "$LEVEL" "Bracket level: '$INPUT'"
test "$_DEBUG_GROUP" "$GROUP" "Group numbers: '$INPUT'"
test "$_DEBUG_STATE" "$STATE" "State numbers: '$INPUT'"
test "$GOTTED_RULES" "$RULES"         "Rules: '$INPUT'"

INPUT='  (   A   )   ...   (   B   )'
LEVEL='0 ( 1 A 1 ) 0 ... 0 ( 1 B 1 ) 0'
GROUP='0 ( 1 A 1 ) 0 ... 0 ( 2 B 2 ) 0'
STATE='0 ( 0 A 1 ) 1 ... 1 ( 1 B 2 ) 2'; FINAL='2'
RULES='0:A -> 1
1:A -> 1
1:B -> 2'
parse GOTTED_RULES $INPUT && :; RETVAL="$?"    # intentionally unquoted
test "$RETVAL"       '0'      'Return value'
test "$_DEBUG_LEVEL" "$LEVEL" "Bracket level: '$INPUT'"
test "$_DEBUG_GROUP" "$GROUP" "Group numbers: '$INPUT'"
test "$_DEBUG_STATE" "$STATE" "State numbers: '$INPUT'"
test "$GOTTED_RULES" "$RULES"         "Rules: '$INPUT'"

INPUT='  (   A   )   (   B   )   ...'
LEVEL='0 ( 1 A 1 ) 0 ( 1 B 1 ) 0 ... 0'
GROUP='0 ( 1 A 1 ) 0 ( 2 B 2 ) 0 ... 0'
STATE='0 ( 0 A 1 ) 1 ( 1 B 2 ) 2 ... 2'; FINAL='2'
RULES='0:A -> 1
1:B -> 2
2:B -> 2'
parse GOTTED_RULES $INPUT && :; RETVAL="$?"    # intentionally unquoted
test "$RETVAL"       '0'      'Return value'
test "$_DEBUG_LEVEL" "$LEVEL" "Bracket level: '$INPUT'"
test "$_DEBUG_GROUP" "$GROUP" "Group numbers: '$INPUT'"
test "$_DEBUG_STATE" "$STATE" "State numbers: '$INPUT'"
test "$GOTTED_RULES" "$RULES"         "Rules: '$INPUT'"

INPUT='  (   A   )   ...   (   B   )   ...'
LEVEL='0 ( 1 A 1 ) 0 ... 0 ( 1 B 1 ) 0 ... 0'
GROUP='0 ( 1 A 1 ) 0 ... 0 ( 2 B 2 ) 0 ... 0'
STATE='0 ( 0 A 1 ) 1 ... 1 ( 1 B 2 ) 2 ... 2'; FINAL='2'
RULES='0:A -> 1
1:A -> 1
1:B -> 2
2:B -> 2'
parse GOTTED_RULES $INPUT && :; RETVAL="$?"    # intentionally unquoted
test "$RETVAL"       '0'      'Return value'
test "$_DEBUG_LEVEL" "$LEVEL" "Bracket level: '$INPUT'"
test "$_DEBUG_GROUP" "$GROUP" "Group numbers: '$INPUT'"
test "$_DEBUG_STATE" "$STATE" "State numbers: '$INPUT'"
test "$GOTTED_RULES" "$RULES"         "Rules: '$INPUT'"

INPUT='  (   (   A   )   B   )'
LEVEL='0 ( 1 ( 2 A 2 ) 1 B 1 ) 0'
GROUP='0 ( 1 ( 2 A 2 ) 1 B 1 ) 0'
STATE='0 ( 0 ( 0 A 2 ) 2 B 1 ) 1'; FINAL='1'
RULES='0:A -> 2
2:B -> 1'
parse GOTTED_RULES $INPUT && :; RETVAL="$?"    # intentionally unquoted
test "$RETVAL"       '0'      'Return value'
test "$_DEBUG_LEVEL" "$LEVEL" "Bracket level: '$INPUT'"
test "$_DEBUG_GROUP" "$GROUP" "Group numbers: '$INPUT'"
test "$_DEBUG_STATE" "$STATE" "State numbers: '$INPUT'"
test "$GOTTED_RULES" "$RULES"         "Rules: '$INPUT'"

INPUT='  (   A   (   B   )   )'
LEVEL='0 ( 1 A 1 ( 2 B 2 ) 1 ) 0'
GROUP='0 ( 1 A 1 ( 2 B 2 ) 1 ) 0'
STATE='0 ( 0 A 2 ( 2 B 3 ) 3 ) 3'; FINAL='3' # (state 1 never used)
RULES='0:A -> 2
2:B -> 3'
parse GOTTED_RULES $INPUT && :; RETVAL="$?"    # intentionally unquoted
test "$RETVAL"       '0'      'Return value'
test "$_DEBUG_LEVEL" "$LEVEL" "Bracket level: '$INPUT'"
test "$_DEBUG_GROUP" "$GROUP" "Group numbers: '$INPUT'"
test "$_DEBUG_STATE" "$STATE" "State numbers: '$INPUT'"
test "$GOTTED_RULES" "$RULES"         "Rules: '$INPUT'"

INPUT='  (   A   (   B   (   C   )   )   )'
LEVEL='0 ( 1 A 1 ( 2 B 2 ( 3 C 3 ) 2 ) 1 ) 0'
GROUP='0 ( 1 A 1 ( 2 B 2 ( 3 C 3 ) 2 ) 1 ) 0'
STATE='0 ( 0 A 2 ( 2 B 4 ( 4 C 5 ) 5 ) 5 ) 5'; FINAL='3' # (state 1 & 3 never used)
RULES='0:A -> 2
2:B -> 4
4:C -> 5'
parse GOTTED_RULES $INPUT && :; RETVAL="$?"    # intentionally unquoted
test "$RETVAL"       '0'      'Return value'
test "$_DEBUG_LEVEL" "$LEVEL" "Bracket level: '$INPUT'"
test "$_DEBUG_GROUP" "$GROUP" "Group numbers: '$INPUT'"
test "$_DEBUG_STATE" "$STATE" "State numbers: '$INPUT'"
test "$GOTTED_RULES" "$RULES"         "Rules: '$INPUT'"

INPUT='  (   A   B   C   |   D   E   F   |   G   H   I   )   X'
LEVEL='0 ( 1 A 1 B 1 C 1 | 1 D 1 E 1 F 1 | 1 G 1 H 1 I 1 ) 0 X 0'
GROUP='0 ( 1 A 1 B 1 C 1 | 1 D 1 E 1 F 1 | 1 G 1 H 1 I 1 ) 0 X 0'
STATE='0 ( 0 A 2 B 3 C 1 | 0 D 4 E 5 F 1 | 0 G 6 H 7 I 1 ) 1 X 8'
RULES='0:A -> 2
2:B -> 3
3:C -> 1
0:D -> 4
4:E -> 5
5:F -> 1
0:G -> 6
6:H -> 7
7:I -> 1
1:X -> 8'
parse GOTTED_RULES $INPUT && :; RETVAL="$?"    # intentionally unquoted
test "$RETVAL"       '0'      'Return value'
test "$_DEBUG_LEVEL" "$LEVEL" "Bracket level: '$INPUT'"
test "$_DEBUG_GROUP" "$GROUP" "Group numbers: '$INPUT'"
test "$_DEBUG_STATE" "$STATE" "State numbers: '$INPUT'"
test "$GOTTED_RULES" "$RULES"         "Rules: '$INPUT'"

INPUT='  [   A   B   C   |   D   E   F   |   G   H   I   ]   X'
LEVEL='0 [ 1 A 1 B 1 C 1 | 1 D 1 E 1 F 1 | 1 G 1 H 1 I 1 ] 0 X 0'
GROUP='0 [ 1 A 1 B 1 C 1 | 1 D 1 E 1 F 1 | 1 G 1 H 1 I 1 ] 0 X 0'
STATE='0 [ 0 A 2 B 3 C 1 | 0 D 4 E 5 F 1 | 0 G 6 H 7 I 1 ] 1 X 8'
## FIXME: These rules should also account for the [...]
RULES='0:A -> 2
2:B -> 3
3:C -> 1
0:D -> 4
4:E -> 5
5:F -> 1
0:G -> 6
6:H -> 7
7:I -> 1
1:X -> 8'
parse GOTTED_RULES $INPUT && :; RETVAL="$?"    # intentionally unquoted
test "$RETVAL"       '0'      'Return value'
test "$_DEBUG_LEVEL" "$LEVEL" "Bracket level: '$INPUT'"
test "$_DEBUG_GROUP" "$GROUP" "Group numbers: '$INPUT'"
test "$_DEBUG_STATE" "$STATE" "State numbers: '$INPUT'"
test "$GOTTED_RULES" "$RULES"         "Rules: '$INPUT'"

INPUT='  [   A   B   C   |   D   E   F   |   G   H   I   ]   ...  X'
LEVEL='0 [ 1 A 1 B 1 C 1 | 1 D 1 E 1 F 1 | 1 G 1 H 1 I 1 ] 0 ... 0 X 0'
GROUP='0 [ 1 A 1 B 1 C 1 | 1 D 1 E 1 F 1 | 1 G 1 H 1 I 1 ] 0 ... 0 X 0'
STATE='0 [ 0 A 2 B 3 C 1 | 0 D 4 E 5 F 1 | 0 G 6 H 7 I 1 ] 1 ... 1 X 8'
## FIXME: These rules should also account for the [...]
unset X                                        # ugly in-string comments
RULES="0:A -> 2
2:B -> 3
3:C -> 1
0:D -> 4
4:E -> 5
5:F -> 1
0:G -> 6
6:H -> 7
7:I -> 1
1:A -> 2${X:+                                  # ellipsis rule }
1:D -> 4${X:+                                  # ellipsis rule }
1:G -> 6${X:+                                  # ellipsis rule }
1:X -> 8"
parse GOTTED_RULES $INPUT && :; RETVAL="$?"    # intentionally unquoted
test "$RETVAL"       '0'      'Return value'
test "$_DEBUG_LEVEL" "$LEVEL" "Bracket level: '$INPUT'"
test "$_DEBUG_GROUP" "$GROUP" "Group numbers: '$INPUT'"
test "$_DEBUG_STATE" "$STATE" "State numbers: '$INPUT'"
test "$GOTTED_RULES" "$RULES"         "Rules: '$INPUT'"

INPUT='  (   A   )'
LEVEL='0 ( 1 A 1 ) 0'
GROUP='0 ( 1 A 1 ) 0'
STATE='0 ( 0 A 1 ) 1'; FINAL='1'
RULES='0:A -> 1'
parse GOTTED_RULES $INPUT && :; RETVAL="$?"    # intentionally unquoted
test "$RETVAL"       '0'      'Return value'
test "$_DEBUG_LEVEL" "$LEVEL" "Bracket level: '$INPUT'"
test "$_DEBUG_GROUP" "$GROUP" "Group numbers: '$INPUT'"
test "$_DEBUG_STATE" "$STATE" "State numbers: '$INPUT'"
test "$GOTTED_RULES" "$RULES"         "Rules: '$INPUT'"

INPUT='  (   (   A   B   )   )'
LEVEL='0 ( 1 ( 2 A 2 B 2 ) 1 ) 0'
GROUP='0 ( 1 ( 2 A 2 B 2 ) 1 ) 0'
STATE='0 ( 0 ( 0 A 3 B 2 ) 2 ) 2'; FINAL="2"
RULES='0:A -> 3
3:B -> 2'
parse GOTTED_RULES $INPUT && :; RETVAL="$?"    # intentionally unquoted
test "$RETVAL"       '0'      'Return value'
test "$_DEBUG_LEVEL" "$LEVEL" "Bracket level: '$INPUT'"
test "$_DEBUG_GROUP" "$GROUP" "Group numbers: '$INPUT'"
test "$_DEBUG_STATE" "$STATE" "State numbers: '$INPUT'"
test "$GOTTED_RULES" "$RULES"         "Rules: '$INPUT'"

INPUT='  [   A   ]'
LEVEL='0 [ 1 A 1 ] 0'
GROUP='0 [ 1 A 1 ] 0'
STATE='0 [ 0 A 1 ] 1'; FINAL="0 1"
## FIXME: These rules should also account for the [...]
RULES='0:A -> 1'
parse GOTTED_RULES $INPUT && :; RETVAL="$?"    # intentionally unquoted
test "$RETVAL"       '0'      'Return value'
test "$_DEBUG_LEVEL" "$LEVEL" "Bracket level: '$INPUT'"
test "$_DEBUG_GROUP" "$GROUP" "Group numbers: '$INPUT'"
test "$_DEBUG_STATE" "$STATE" "State numbers: '$INPUT'"
test "$GOTTED_RULES" "$RULES"         "Rules: '$INPUT'"

INPUT='  (   A   |   B   )'
LEVEL='0 ( 1 A 1 | 1 B 1 ) 0'
GROUP='0 ( 1 A 1 | 1 B 1 ) 0'
STATE='0 ( 0 A 1 | 0 B 1 ) 1'; FINAL=1
RULES='0:A -> 1
0:B -> 1'
parse GOTTED_RULES $INPUT && :; RETVAL="$?"    # intentionally unquoted
test "$RETVAL"       '0'      'Return value'
test "$_DEBUG_LEVEL" "$LEVEL" "Bracket level: '$INPUT'"
test "$_DEBUG_GROUP" "$GROUP" "Group numbers: '$INPUT'"
test "$_DEBUG_STATE" "$STATE" "State numbers: '$INPUT'"
test "$GOTTED_RULES" "$RULES"         "Rules: '$INPUT'"

INPUT='  (   A   |   B   )   ...'
LEVEL='0 ( 1 A 1 | 1 B 1 ) 0 ... 0'
GROUP='0 ( 1 A 1 | 1 B 1 ) 0 ... 0'
STATE='0 ( 0 A 1 | 0 B 1 ) 1 ... 1'; FINAL=1
RULES='0:A -> 1
0:B -> 1
1:A -> 1
1:B -> 1'
parse GOTTED_RULES $INPUT && :; RETVAL="$?"    # intentionally unquoted
test "$RETVAL"       '0'      'Return value'
test "$_DEBUG_LEVEL" "$LEVEL" "Bracket level: '$INPUT'"
test "$_DEBUG_GROUP" "$GROUP" "Group numbers: '$INPUT'"
test "$_DEBUG_STATE" "$STATE" "State numbers: '$INPUT'"
test "$GOTTED_RULES" "$RULES"         "Rules: '$INPUT'"

INPUT='  A   ...   B'
LEVEL='0 A 0 ... 0 B 0'
GROUP='0 A 0 ... 0 B 0'
STATE='0 A 1 ... 1 B 2'; FINAL=2
RULES='0:A -> 1
1:A -> 1
1:B -> 2'
parse GOTTED_RULES $INPUT && :; RETVAL="$?"    # intentionally unquoted
test "$RETVAL"       '0'      'Return value'
test "$_DEBUG_LEVEL" "$LEVEL" "Bracket level: '$INPUT'"
test "$_DEBUG_GROUP" "$GROUP" "Group numbers: '$INPUT'"
test "$_DEBUG_STATE" "$STATE" "State numbers: '$INPUT'"
test "$GOTTED_RULES" "$RULES"         "Rules: '$INPUT'"

INPUT='  (   A   ) ... B'
LEVEL='0 ( 1 A 1 ) 0 ... 0 B 0'
GROUP='0 ( 1 A 1 ) 0 ... 0 B 0'
STATE='0 ( 0 A 1 ) 1 ... 1 B 2'; FINAL=2
RULES='0:A -> 1
1:A -> 1
1:B -> 2'
parse GOTTED_RULES $INPUT && :; RETVAL="$?"    # intentionally unquoted
test "$RETVAL"       '0'      'Return value'
test "$_DEBUG_LEVEL" "$LEVEL" "Bracket level: '$INPUT'"
test "$_DEBUG_GROUP" "$GROUP" "Group numbers: '$INPUT'"
test "$_DEBUG_STATE" "$STATE" "State numbers: '$INPUT'"
test "$GOTTED_RULES" "$RULES"         "Rules: '$INPUT'"

INPUT='  (   A   B   )   ...'
LEVEL='0 ( 1 A 1 B 1 ) 0 ... 0'
GROUP='0 ( 1 A 1 B 1 ) 0 ... 0'
STATE='0 ( 0 A 2 B 1 ) 1 ... 1'; FINAL=2
RULES='0:A -> 2
2:B -> 1
1:A -> 2'
parse GOTTED_RULES $INPUT && :; RETVAL="$?"    # intentionally unquoted
test "$RETVAL"       '0'      'Return value'
test "$_DEBUG_LEVEL" "$LEVEL" "Bracket level: '$INPUT'"
test "$_DEBUG_GROUP" "$GROUP" "Group numbers: '$INPUT'"
test "$_DEBUG_STATE" "$STATE" "State numbers: '$INPUT'"
test "$GOTTED_RULES" "$RULES"         "Rules: '$INPUT'"

INPUT='  (   A   )   (   B   )'
LEVEL='0 ( 1 A 1 ) 0 ( 1 B 1 ) 0'
GROUP='0 ( 1 A 1 ) 0 ( 2 B 2 ) 0'
STATE='0 ( 0 A 1 ) 1 ( 1 B 2 ) 2'; FINAL="2"
RULES='0:A -> 1
1:B -> 2'
parse GOTTED_RULES $INPUT && :; RETVAL="$?"    # intentionally unquoted
test "$RETVAL"       '0'      'Return value'
test "$_DEBUG_LEVEL" "$LEVEL" "Bracket level: '$INPUT'"
test "$_DEBUG_GROUP" "$GROUP" "Group numbers: '$INPUT'"
test "$_DEBUG_STATE" "$STATE" "State numbers: '$INPUT'"
test "$GOTTED_RULES" "$RULES"         "Rules: '$INPUT'"

INPUT='  (   A   )   (   B   )   ...'
LEVEL='0 ( 1 A 1 ) 0 ( 1 B 1 ) 0 ... 0'
GROUP='0 ( 1 A 1 ) 0 ( 2 B 2 ) 0 ... 0'
STATE='0 ( 0 A 1 ) 1 ( 1 B 2 ) 2 ... 2'; FINAL=2
RULES='0:A -> 1
1:B -> 2
2:B -> 2'
parse GOTTED_RULES $INPUT && :; RETVAL="$?"    # intentionally unquoted
test "$RETVAL"       '0'      'Return value'
test "$_DEBUG_LEVEL" "$LEVEL" "Bracket level: '$INPUT'"
test "$_DEBUG_GROUP" "$GROUP" "Group numbers: '$INPUT'"
test "$_DEBUG_STATE" "$STATE" "State numbers: '$INPUT'"
test "$GOTTED_RULES" "$RULES"         "Rules: '$INPUT'"

# FIXME: Since state '1' was eaten here, the last rule output
# FIXME: When we have a case of multiple endings ) )... we must update _END$_LVL for those groups
# FIXME: Implement rules here
INPUT='  (   A   (   B   )   )   ...'
LEVEL='0 ( 1 A 1 ( 2 B 2 ) 1 ) 0 ... 0'
GROUP='0 ( 1 A 1 ( 2 B 2 ) 1 ) 0 ... 0'
STATE='0 ( 0 A 2 ( 2 B 3 ) 3 ) 3 ... 3'; FINAL=3
RULES='0:A -> 2
2:B -> 3
3:A -> 2'
parse GOTTED_RULES $INPUT && :; RETVAL="$?"    # intentionally unquoted
test "$RETVAL"       '0'      'Return value'
test "$_DEBUG_LEVEL" "$LEVEL" "Bracket level: '$INPUT'"
test "$_DEBUG_GROUP" "$GROUP" "Group numbers: '$INPUT'"
test "$_DEBUG_STATE" "$STATE" "State numbers: '$INPUT'"
test "$GOTTED_RULES" "$RULES"         "Rules: '$INPUT'"

# FIXME: Since state '1' was eaten here, the last rule output
# FIXME: when we have a case of multiple endings ) )... we must update _END$_LVL for those groups
# FIXME: Implement rules here
INPUT='  (   A   (   B   (   C   )   )   )   ...'
LEVEL='0 ( 1 A 1 ( 2 B 2 ( 3 C 3 ) 2 ) 1 ) 0 ... 0'
GROUP='0 ( 1 A 1 ( 2 B 2 ( 3 C 3 ) 2 ) 1 ) 0 ... 0'
STATE='0 ( 0 A 2 ( 2 B 4 ( 4 C 5 ) 5 ) 5 ) 5 ... 5'; FINAL=5
RULES='0:A -> 2
2:B -> 4
4:C -> 5
5:A -> 2'
parse GOTTED_RULES $INPUT && :; RETVAL="$?"    # intentionally unquoted
test "$RETVAL"       '0'      'Return value'
test "$_DEBUG_LEVEL" "$LEVEL" "Bracket level: '$INPUT'"
test "$_DEBUG_GROUP" "$GROUP" "Group numbers: '$INPUT'"
test "$_DEBUG_STATE" "$STATE" "State numbers: '$INPUT'"
test "$GOTTED_RULES" "$RULES"         "Rules: '$INPUT'"



# FIXME: Add test cases for 
INPUT='  (   (   A   )   ...   B   )'
INPUT='  (   (   A   )   ...   B   )   ...'
INPUT='  (   (   A   )   B   )   ...'
INPUT='  (   (   (   A   )   B   )   C   )   ...'
INPUT='  (   (   (   A   )   ...   B   )   C   )   ...'

INPUT='  (   A   ...   )   ...'          # Does this make sense?
INPUT='  (   A   ...   |   B   )   ...'  # This does!

# FIXME: Since state '1' was eaten here, the last rule output
# FIXME: when we have a case of multiple endings ) )... we must update _END$_LVL for those groups
INPUT='  (   (   A   )   B   )   ...'
LEVEL='0 ( 1 ( 2 A 2 ) 1 B 1 ) 0 ... 0'
GROUP='0 ( 1 ( 2 A 2 ) 1 B 1 ) 0 ... 0'
STATE='0 ( 0 ( 0 A 2 ) 2 B 1 ) 1 ... 1'; FINAL=1
RULES='0:A -> 2
2:B -> 1
1:A -> 2'
parse GOTTED_RULES $INPUT && :; RETVAL="$?"    # intentionally unquoted
test "$RETVAL"       '0'      'Return value'
test "$_DEBUG_LEVEL" "$LEVEL" "Bracket level: '$INPUT'"
test "$_DEBUG_GROUP" "$GROUP" "Group numbers: '$INPUT'"
test "$_DEBUG_STATE" "$STATE" "State numbers: '$INPUT'"
test "$GOTTED_RULES" "$RULES"         "Rules: '$INPUT'"

INPUT='  (   (   A   )   ...   B   )'
LEVEL='0 ( 1 ( 2 A 2 ) 1 ... 1 B 1 ) 0'
GROUP='0 ( 1 ( 2 A 2 ) 1 ... 1 B 1 ) 0'
STATE='0 ( 0 ( 0 A 2 ) 2 ... 2 B 1 ) 1'; FINAL=1
RULES='0:A -> 2
2:A -> 2
2:B -> 1'
parse GOTTED_RULES $INPUT && :; RETVAL="$?"    # intentionally unquoted
test "$RETVAL"       '0'      'Return value'
test "$_DEBUG_LEVEL" "$LEVEL" "Bracket level: '$INPUT'"
test "$_DEBUG_GROUP" "$GROUP" "Group numbers: '$INPUT'"
test "$_DEBUG_STATE" "$STATE" "State numbers: '$INPUT'"
test "$GOTTED_RULES" "$RULES"         "Rules: '$INPUT'"

INPUT='  (   (   A   )   ...   B   )   ...'
LEVEL='0 ( 1 ( 2 A 2 ) 1 ... 1 B 1 ) 0 ... 0'
GROUP='0 ( 1 ( 2 A 2 ) 1 ... 1 B 1 ) 0 ... 0'
STATE='0 ( 0 ( 0 A 2 ) 2 ... 2 B 1 ) 1 ... 1'; FINAL=1
RULES='0:A -> 2
2:A -> 2
2:B -> 1
1:A -> 2'
parse GOTTED_RULES $INPUT && :; RETVAL="$?"    # intentionally unquoted
test "$RETVAL"       '0'      'Return value'
test "$_DEBUG_LEVEL" "$LEVEL" "Bracket level: '$INPUT'"
test "$_DEBUG_GROUP" "$GROUP" "Group numbers: '$INPUT'"
test "$_DEBUG_STATE" "$STATE" "State numbers: '$INPUT'"
test "$GOTTED_RULES" "$RULES"         "Rules: '$INPUT'"

######################################################################
##
##  Tests from Finite State Automaton Images
##

INPUT='  (   A   B   C   |   D   E   F   |   G   H   I   )'
LEVEL='0 ( 1 A 1 B 1 C 1 | 1 D 1 E 1 F 1 | 1 G 1 H 1 I 1 ) 0'
GROUP='0 ( 1 A 1 B 1 C 1 | 1 D 1 E 1 F 1 | 1 G 1 H 1 I 1 ) 0'
STATE='0 ( 0 A 2 B 3 C 1 | 0 D 4 E 5 F 1 | 0 G 6 H 7 I 1 ) 1'; FINAL=1
RULES='0:A -> 2
2:B -> 3
3:C -> 1
0:D -> 4
4:E -> 5
5:F -> 1
0:G -> 6
6:H -> 7
7:I -> 1'
#1: -> X'                                      # FIXME: eol (or next grouping)
# FIXME: Code should produce the (above) finishing state
parse GOTTED_RULES $INPUT && :; RETVAL="$?"    # intentionally unquoted
test "$RETVAL"       '0'      'Return value'
test "$_DEBUG_LEVEL" "$LEVEL" "Bracket level: '$INPUT'"
test "$_DEBUG_GROUP" "$GROUP" "Group numbers: '$INPUT'"
test "$_DEBUG_STATE" "$STATE" "State numbers: '$INPUT'"
test "$GOTTED_RULES" "$RULES"         "Rules: '$INPUT'"

INPUT='  [   A   B   C   |   D   E   F   |   G   H   I   ]'
LEVEL='0 [ 1 A 1 B 1 C 1 | 1 D 1 E 1 F 1 | 1 G 1 H 1 I 1 ] 0'
GROUP='0 [ 1 A 1 B 1 C 1 | 1 D 1 E 1 F 1 | 1 G 1 H 1 I 1 ] 0'
STATE='0 [ 0 A 2 B 3 C 1 | 0 D 4 E 5 F 1 | 0 G 6 H 7 I 1 ] 1'; FINAL="0 1"
RULES='0:A -> 2
2:B -> 3
3:C -> 1
0:D -> 4
4:E -> 5
5:F -> 1
0:G -> 6
6:H -> 7
7:I -> 1'
#1: -> X                                       # FIXME: eol (or next grouping)
#0: -> X'                                      # FIXME: eol (or next grouping)
# FIXME: Code should produce the (above) finishing states
parse GOTTED_RULES $INPUT && :; RETVAL="$?"    # intentionally unquoted
test "$RETVAL"       '0'      'Return value'
test "$_DEBUG_LEVEL" "$LEVEL" "Bracket level: '$INPUT'"
test "$_DEBUG_GROUP" "$GROUP" "Group numbers: '$INPUT'"
test "$_DEBUG_STATE" "$STATE" "State numbers: '$INPUT'"
test "$GOTTED_RULES" "$RULES"         "Rules: '$INPUT'"

INPUT='  (   A   B   C   |   D   E   F   |   G   H   I   )   ...'
LEVEL='0 ( 1 A 1 B 1 C 1 | 1 D 1 E 1 F 1 | 1 G 1 H 1 I 1 ) 0 ... 0'
GROUP='0 ( 1 A 1 B 1 C 1 | 1 D 1 E 1 F 1 | 1 G 1 H 1 I 1 ) 0 ... 0'
STATE='0 ( 0 A 2 B 3 C 1 | 0 D 4 E 5 F 1 | 0 G 6 H 7 I 1 ) 1 ... 1'; FINAL=1
unset X                                        # ugly in-string comments
RULES="0:A -> 2
2:B -> 3
3:C -> 1
0:D -> 4
4:E -> 5
5:F -> 1
0:G -> 6
6:H -> 7
7:I -> 1
1:A -> 2${X:+                                  # ellipsis rule }
1:D -> 4${X:+                                  # ellipsis rule }
1:G -> 6${X:+                                  # ellipsis rule }"
#1: -> X'                                      # FIXME: eol (or next grouping)
# FIXME: Code should produce the (above) finishing state
parse GOTTED_RULES $INPUT && :; RETVAL="$?"    # intentionally unquoted
test "$RETVAL"       '0'      'Return value'
test "$_DEBUG_LEVEL" "$LEVEL" "Bracket level: '$INPUT'"
test "$_DEBUG_GROUP" "$GROUP" "Group numbers: '$INPUT'"
test "$_DEBUG_STATE" "$STATE" "State numbers: '$INPUT'"
test "$GOTTED_RULES" "$RULES"         "Rules: '$INPUT'"

INPUT='  [   A   B   C   |   D   E   F   |   G   H   I   ] ...'
LEVEL='0 [ 1 A 1 B 1 C 1 | 1 D 1 E 1 F 1 | 1 G 1 H 1 I 1 ] 0 ... 0'
GROUP='0 [ 1 A 1 B 1 C 1 | 1 D 1 E 1 F 1 | 1 G 1 H 1 I 1 ] 0 ... 0'
STATE='0 [ 0 A 2 B 3 C 1 | 0 D 4 E 5 F 1 | 0 G 6 H 7 I 1 ] 1 ... 1'; FINAL="0 1"
unset X                                        # ugly in-string comments
RULES="0:A -> 2
2:B -> 3
3:C -> 1
0:D -> 4
4:E -> 5
5:F -> 1
0:G -> 6
6:H -> 7
7:I -> 1
1:A -> 2${X:+                                  # ellipsis rule }
1:D -> 4${X:+                                  # ellipsis rule }
1:G -> 6${X:+                                  # ellipsis rule }"
#1: -> X                                       # FIXME: eol (or next grouping)
#0: -> X'                                      # FIXME: eol (or next grouping)
# FIXME: Code should produce the (above) finishing state
BEGENV="$(dumpenv \
    _DEBUG_STATE _DEBUG_GROUP _DEBUG_LEVEL \
    BEGENV ENDENV TESTS_COUNT FAILED_TESTS TMPNUM)" # expect
parse GOTTED_RULES $INPUT && :; RETVAL="$?"    # intentionally unquoted
test "$RETVAL"       '0'      'Return value'
test "$_DEBUG_LEVEL" "$LEVEL" "Bracket level: '$INPUT'"
test "$_DEBUG_GROUP" "$GROUP" "Group numbers: '$INPUT'"
test "$_DEBUG_STATE" "$STATE" "State numbers: '$INPUT'"
test "$GOTTED_RULES" "$RULES"         "Rules: '$INPUT'"
ENDENV="$(dumpenv \
    _DEBUG_STATE _DEBUG_GROUP _DEBUG_LEVEL \
    BEGENV ENDENV TESTS_COUNT FAILED_TESTS TMPNUM)" # got
test "$ENDENV" "$BEGENV"      "Variable leakage: '$INPUT'"

done_testing

#[eof]

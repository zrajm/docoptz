#!/bin/sh

#DEBUG=1
if [ "$DEBUG" ]; then
    DEBUG() { {
        printf '%s\n' "$1"; shift
        printf '    %s\n' "$@"
    } >&2; }
else
    DEBUG() { :; }
fi

################################################################################

die() {
    printf '%s: %s\n' "${0##*/}" "$*"
    exit 5
}
varname_or_die() {
    H="${1:+$1: }"; shift
    for V in "$@"; do
        case "$V" in *[!A-Z0-9_]*|[0-9]*) die "${H}Bad varname '$V'"; esac
    done
}
int_or_die() {
    H="${1:+$1: }"; shift
    for V in "$@"; do
        case "$V" in *[!0-9]*) die "${H}Bad integer '$V'"; esac
    done
}
# Usage: getvar VARNAME1 VARNAME2
#
# Variable VARNAME1 is set to whatever variable VARNAME2 contains.
getvar() { varname_or_die getvar "$1" "$2"; _getvar "$@"; }
_getvar() { eval "$1=\"\$$2\""; }

# Usage: getvar VARNAME1 VARNAME2
#
# Variable VARNAME1 is set to whatever variable VARNAME2 contains.
getint() { varname_or_die getint "$1" "$2"; _getint "$@"; }
_getint() {
    eval "$1=\"\$$2\"";
    int_or_die getint "$1";
}


# Usage: setvar VARNAME VALUE
#
# Set variable VARNAME to the specified value.
setvar() { varname_or_die setvar "$1"; _setvar "$@"; }
_setvar() { eval "$1=\"\$2\""; }

# Usage: incvar VARNAME
#
# Sets variable VARNAME to 0 if unset, otherwise increment VARNAME by one.
incvar() { varname_or_die incvar "$1"; _incvar "$@"; }
_incvar() { eval "$1=\"\$((\${$1:--1} + 1))\""; } #VAR="$((${VAR:--1} + 1))"

# Usage: decvar VARNAME
#
# Sets variable VARNAME to 0 if unset, otherwise decrement VARNAME by one.
decvar() { varname_or_die decvar "$1"; _decvar "$@"; }
_decvar() { _setvar "$1" "$(($1 - 1))"; }

# Usage: VARNAME VALUE
#
# Set varible VARNAME to VALUE, except remove all trailing '.0' first.
stripzeroes() {
    #R="$STATE"
    #while [ "$R" != "${R%.0}" ]; do R="${R%.0}"; done
    eval "$1=\"\$2\";
    while [ \"\$$1\" != \"\${$1%.0}\" ]; do $1=\"\${$1%.0}\"; done"
}

# Usage: increment_state STATE
#
# Where STATE is a number like '0' or '1.2' or '0.2.3'. Increments last digit
# of state by one.
increment_state() {
    # case "$STATE" in
    #     *.*) STATE="${STATE%.*}.$((${STATE##*.}+1))";;
    #     *) STATE="$((STATE+1))"
    # esac
    varname_or_die increment_state "$1"
    eval "case \"\$$1\" in
        *.*) $1=\"\${$1%.*}.\$((\${$1##*.}+1))\";;
        *) $1=\"\$(($1+1))\"
    esac"
}

# Usage: LEVELVAR STATEVAR
#
# Goes one level deeper into hierarchy, by adding one to LEVELVAR and appending
# a '.SUBSTATE' number to STATEVAR. SUBSTATE is guaranteed to be unique for
# each LEVEL. (Uses forever incrementing variables ${LAST$LVL} to keep track of
# which substates to use.)
add_substate() {
    varname_or_die add_substate "$1" "$2"
    local _LVL
    _incvar "$1"                      # increment level
    _getvar _LVL "$1"                 #   get level value
    int_or_die add_substate "$_LVL"
    _incvar "LAST$_LVL"               # increment last substate
    # STATE="$STATE.${LAST$_LVL}"
    eval "$2=\"\$$2.\$LAST$_LVL\""    # append last substate to state
}

# remove_substate() {
#     varname_or_die remove_substate "$2"
#     # LVL="$((LVL-1))"
#     #eval "$1=\"\$(($1-1))\""  # decrement LVL
#     setvar "$1" "$(($1-1))"    # decrement LVL
#     # STATE="${STATE%.*}"
#     eval "$2=\"\${$2%.*}\""    # remove number from STATE
# }

# Usage: remove_level STATE LVL
remove_level() {
    # LVL="$((LVL-1))"
    #eval "$1=\"\$(($1-1))\""  # decrement LVL
    setvar "$1" "$(($1-1))"    # decrement LVL
    # STATE="${STATE%.*}"
    varname_or_die remove_level "$2"
    eval "$2=\"\${$2%.*}\""    # remove number from STATE
}

output_rule() {
    local STATE="$2" _RULE
    getvar _RULE "$1"
    [ "$_RULE" ] && printf "%s -> %s\n" "$_RULE" "$STATE"
    unset "$1"
}

# Usage: push_state LVL STATEVAR
#
# Increment LVL by one, and add another substate onto STATEVAR. STATEVAR has
# the syntax STATE[_SUBSTATE[_SUBSUBSTATE]], with '_' as separator between
# states. STATE is guaranteed to be unique.

#### Goes one level deeper into hierarchy, by adding one to LEVELVAR and appending
#### a '.SUBSTATE' number to STATEVAR. SUBSTATE is guaranteed to be unique for
#### each LEVEL. (Uses forever incrementing variables ${LAST$LVL} to keep track of
#### which substates to use.)
push_state() {
    varname_or_die push_state "$1" "$2"                                    ## from add_substate
    local _LVL                                                             ## from add_substate
    _incvar "$1"                      # increment level                    ## from add_substate
    _getvar _LVL "$1"                 #   get level value                  ## from add_substate
    int_or_die push_state "$_LVL"                                          ## from add_substate
    _incvar "LAST$_LVL"               # increment last substate            ## from add_substate
    # STATE="$STATE.${LAST$_LVL}"                                          ## from add_substate
    eval "$2=\"\$$2.\$LAST$_LVL\""    # append last substate to state      ## from add_substate

    # varname_or_die push_state "$@"
    # local _LVL
    # _incvar "$1"                      # increment level
    # _getvar _LVL "$1"                 #   get level value
    # _incvar "LAST$_LVL"               # increment last substate
    # # STATE="$STATE.${LAST$_LVL}"
    # eval "$2=\"\$${2}_\$LAST$_LVL\""    # append last substate to state
}
# Usage: pop_state LVL STATEVAR
pop_state() {
    varname_or_die pop_state "$@"
    _decvar "$1"                # decrement LVL
    eval "$2=\"\${$2%.*}\""     # remove number from STATE
}
# Usage: inc_state STATEVAR
inc_state() {
    varname_or_die inc_state "$1"
    # case "$STATE" in
    #     *.*) STATE="${STATE%.*}.$((${STATE##*.}+1))";;
    #     *) STATE="$((STATE+1))"
    # esac
    eval "case \"\$$1\" in
        *.*) $1=\"\${$1%.*}.\$((\${$1##*.}+1))\";;
        *) $1=\"\$(($1+1))\"
    esac"
}

# Usage: preparse TOKENIZED
#
# Go through TOKENIZED and populate environment with variables needed for
# 'parse' to know the end state of each parethetic group. (FIXME: Also check
# nesting for correctness?)
preparse() {
    local LVL=0 RULE='' STATE=0 INDENT=''
    local OUT=''
    for A in "$@"; do
        DEBUG="$A"
        OUT="${OUT:+$OUT }$STATE $A"
        case "$A" in
            '('|'[')                           # start parenthesis or bracket
                push_state LVL STATE
                #add_substate LVL STATE         #   add substate
                setvar "BEG$LVL" "$STATE"      #     remember opening state

                NEXTINDENT="    $INDENT"
                #add_substate LVL2 STATE         #   add substate
                #setvar "BEG$LVL" "$STATE"       #     remember opening state
                ;;
            ']'|')')                           # end bracket
                # pop_state LVL STATE
                unset "BEG$LVL"                #   forget opening state
                pop_state LVL STATE
                #remove_level LVL STATE
                increment_state STATE

                INDENT="${INDENT#    }"
                NEXTINDENT="$INDENT"
                #unset "BEG$LVL"                #   forget opening state
                #remove_level LVL2 STATE
                ;;
            '|')                               #   pipe
                getvar STATE "BEG$LVL"         #     return state to start bracket
                NEXTINDENT="$INDENT"
                INDENT="${INDENT#  }"
                ;;
            *)                                 #   anything else
                increment_state STATE
            ;;
        esac
        out "$INDENT>>$A"
        echo "  ${INDENT}LVL:$LVL STATE:$STATE"
        INDENT="$NEXTINDENT"
    done
    printf '%s\n' "OUT: $OUT $STATE"
    # if [ "$LVL" -gt 0 ]; then
    #     die "Too few ending parentheses!!"
    # fi
}


parse() {
    printf '%s\n' "$*"
    local LVL=0 RULE='' STATE=0
    for A in "$@"; do
        DEBUG="$A"
        case "$A" in
            '('|'[')                           # start parenthesis or bracket
                output_rule RULE "$STATE"
                add_substate LVL STATE         #   add substate
                setvar "BEG$LVL" "$STATE"      #     remember opening state
            ;;
            ')')                               # end parenthesis
                # FIXME: STATE should end in '.x'
                output_rule RULE "${STATE%.*}.x"
                unset "BEG$LVL"                #   forget opening state
                remove_level LVL STATE
                increment_state STATE
            ;;
            ']')                               # end bracket
                # FIXME: STATE should end in '.x'
                output_rule RULE "${STATE%.*}.x"
                unset "BEG$LVL"                #   forget opening state
                remove_level LVL STATE
            ;;
            '|')                               #   pipe
                # FIXME: STATE should end in '.x'
                output_rule RULE "${STATE%.*}.x"
                getvar STATE "BEG$LVL"         #     return state to start bracket
            ;;
            *)                                 #   anything else
                output_rule RULE "$STATE"

                stripzeroes REDUCED "$STATE"
                #echo "REDUCED:$STATE -> $REDUCED"
                REDUCED="$STATE"
                while [ "$REDUCED" != "${REDUCED%.0}" ]; do
                    REDUCED="${REDUCED%.0}"
                done

                RULE="$REDUCED:$A"
                increment_state STATE
                #setvar "USED$LVL" "${STATE##*.}"
                # increase USED
            ;;
        esac
        local USED BEG
        getvar USED "USED$LVL"
        getvar BEG  "BEG$LVL"

        DEBUG "$DEBUG" "STATE: $STATE" "LVL: $LVL" "BEG$LVL: $BEG" "USED$LVL: $USED"
    done
    if [ "$LVL" -gt 0 ]; then
        die "Too few ending parentheses!!"
    fi
}

################################################################################

# What 'echo' SHOULD do.
out() {
    printf '%s\n' "$*"
}

# PREPARSE, note of ending for each paren. connect the BEG$LVL or similr of
# each paren to a definite end to use.

X='  fire   ( bullet | torpedo ( traditional | smart ) )   ( target NAME | randomly )'
out $X        # intentionally unquoted
preparse $X   # intentionally unquoted

exit

__END__
################################################################################
################################################################################
################################################################################
################################################################################
################################################################################


#           1.0      1.1      1.2           1.2.1
X='0 fire 1 ( bullet | torpedo ( traditional | smart ) ) 2 ( target NAME | randomly ) 3'
X='  fire   ( bullet | torpedo ( traditional | smart ) )   ( target NAME | randomly ) 3'

cat <<EXPECTED
$X
0:fire -> 1
1:bullet -> 2
1:torpedo -> 1.1
1.1:traditional -> 1.

EXPECTED


exit
:<<'BLOCK_COMMENT'

#parse thingy '(' ')' '(' ')' '(' ')' '(' ')'

parse thingy '[' tool '|' lamp ']' '(' on '|' off ')' '(' green '|' blue ')'

echo --------------------------------------------------------------------------------
X="( lamp | machine ) ( on | off | dim VALUE )"

cat <<EOF
EXPECTED
$X
0:lamp -> 1
0:machine -> 1
1:on -> 2
1:off -> 2
1:dim -> 1.1
1.1:* -> 2
EOF

parse $X

echo --------------------------------------------------------------------------------
X="0 ( 0.0 a 0.1 (0.1.0 b 0.1.1 (0.1.1.0 c 0.1.1.1 )  ) ) 1"
X="( a ( b ( c ) ) )"
cat <<EOF
EXPECTED
$X
0:a -> 0.1
0.1:b -> 0.1.0
1.1:c -> 1
EOF

parse $X

BLOCK_COMMENT

echo --------------------------------------------------------------------------------
LINE='my_program go ( --up | --down | --left | --right )'

cat <<EXPECTED
$LINE
0:go -> 1
1:--up -> 2
1:--down -> 2
1:--left -> 2
1:--right -> 2
DONE=2
--------------------
EXPECTED
LINE="${LINE#* }"
parse $LINE

#[eof]

#!/bin/sh

# FIXME: Remove dead code
# FIXME: is pop/push etc used? If not move to different file.

#DEBUG=1
if [ "$DEBUG" ]; then
    DEBUG() { {
        printf '%s\n' "$1"; shift
        printf '    %s\n' "$@"
    } >&2; }
else
    DEBUG() { :; }
fi

################################################################################

out() { printf '%s\n' "$*"; }
die() { warn "$@"; exit 5; }
warn() { printf '%s: %s\n' "${0##*/}" "$*" >&2; :; } # always return true
varname_or_die() {
    local H V
    H="${1:+$1: }"; shift
    for V in "$@"; do
        case "$V" in *[!A-Z0-9_]*|[0-9]*) die "${H}Bad variable name '$V'"; esac
    done
}
int_or_die() {
    local H V
    H="${1:+$1: }"; shift
    for V in "$@"; do
        case "$V" in *[!0-9]*) die "${H}Bad integer '$V'"; esac
    done
}
# Usage: getvar VARNAME1 VARNAME2
#
# Variable VARNAME1 is set to whatever variable VARNAME2 contains.
getvar() { varname_or_die getvar "$1" "$2"; _getvar "$@"; }
_getvar() { eval "$1=\"\$$2\""; }

# Usage: getvar VARNAME1 VARNAME2
#
# Variable VARNAME1 is set to whatever variable VARNAME2 contains.
getint() { varname_or_die getint "$1" "$2"; _getint "$@"; }
_getint() {
    eval "$1=\"\$$2\"";
    int_or_die getint "$1";
}

# Usage: append VARNAME STRING
#
# Append STRING to VARNAME with a space inbetween (unless VARNAME is empty, in
# which case no space is inserted in front of STRING).
append() {
    varname_or_die append "$1";
    # VARNAME="${VARNAME:+$VARNAME }$2"
    eval "$1=\"\${$1:+\$$1 }\$2\""
}

# Usage: lfappend VARNAME STRING
#
# Append STRING to VARNAME with a space inbetween (unless VARNAME is empty, in
# which case no space is inserted in front of STRING).
lfappend() {
    varname_or_die append "$1";
    # VARNAME="${VARNAME:+$VARNAME<NEWLINE>}$2"
    eval "$1=\"\${$1:+\$$1
}\$2\""                                        # intentional linebreak
}

# Usage: setvar VARNAME VALUE
#
# Set variable VARNAME to the specified value.
setvar() { varname_or_die setvar "$1"; _setvar "$@"; }
_setvar() { eval "$1=\"\$2\""; }

# Usage: incvar VARNAME
#
# Sets variable VARNAME to 0 if unset, otherwise increment VARNAME by one.
incvar() { varname_or_die incvar "$1"; _incvar "$@"; }
_incvar() { eval "$1=\"\$((\${$1:--1} + 1))\""; } #VAR="$((${VAR:--1} + 1))"

# Usage: decvar VARNAME
#
# Sets variable VARNAME to 0 if unset, otherwise decrement VARNAME by one.
decvar() { varname_or_die decvar "$1"; _decvar "$@"; }
_decvar() { _setvar "$1" "$(($1 - 1))"; }

# Usage: VARNAME VALUE
#
# Set varible VARNAME to VALUE, except remove all trailing '.0' first.
stripzeroes() {
    #R="$STATE"
    #while [ "$R" != "${R%.0}" ]; do R="${R%.0}"; done
    eval "$1=\"\$2\";
    while [ \"\$$1\" != \"\${$1%.0}\" ]; do $1=\"\${$1%.0}\"; done"
}

# Usage: increment_state STATE
#
# Where STATE is a number like '0' or '1.2' or '0.2.3'. Increments last digit
# of state by one.
increment_state() {
    # case "$STATE" in
    #     *.*) STATE="${STATE%.*}.$((${STATE##*.}+1))";;
    #     *) STATE="$((STATE+1))"
    # esac
    varname_or_die increment_state "$1"
    eval "case \"\$$1\" in
        *.*) $1=\"\${$1%.*}.\$((\${$1##*.}+1))\";;
        *) $1=\"\$(($1+1))\"
    esac"
}

# Usage: LEVELVAR STATEVAR
#
# Goes one level deeper into hierarchy, by adding one to LEVELVAR and appending
# a '.SUBSTATE' number to STATEVAR. SUBSTATE is guaranteed to be unique for
# each LEVEL. (Uses forever incrementing variables ${LAST$LVL} to keep track of
# which substates to use.)
add_substate() {
    varname_or_die add_substate "$1" "$2"
    local _LVL
    _incvar "$1"                      # increment level
    _getvar _LVL "$1"                 #   get level value
    int_or_die add_substate "$_LVL"
    _incvar "LAST$_LVL"               # increment last substate
    # STATE="$STATE.${LAST$_LVL}"
    eval "$2=\"\$$2.\$LAST$_LVL\""    # append last substate to state
}

# remove_substate() {
#     varname_or_die remove_substate "$2"
#     # LVL="$((LVL-1))"
#     #eval "$1=\"\$(($1-1))\""  # decrement LVL
#     setvar "$1" "$(($1-1))"    # decrement LVL
#     # STATE="${STATE%.*}"
#     eval "$2=\"\${$2%.*}\""    # remove number from STATE
# }

# Usage: remove_level STATE LVL
remove_level() {
    # LVL="$((LVL-1))"
    #eval "$1=\"\$(($1-1))\""  # decrement LVL
    setvar "$1" "$(($1-1))"    # decrement LVL
    # STATE="${STATE%.*}"
    varname_or_die remove_level "$2"
    eval "$2=\"\${$2%.*}\""    # remove number from STATE
}

output_rule() {
    local STATE="$2" _RULE
    getvar _RULE "$1"
    [ "$_RULE" ] && printf "%s -> %s\n" "$_RULE" "$STATE"
    unset "$1"
}

# Usage: push_state LVL STATEVAR
#
# Increment LVL by one, and add another substate onto STATEVAR. STATEVAR has
# the syntax STATE[_SUBSTATE[_SUBSUBSTATE]], with '_' as separator between
# states. STATE is guaranteed to be unique.
#
#### Goes one level deeper into hierarchy, by adding one to LEVELVAR and appending
#### a '.SUBSTATE' number to STATEVAR. SUBSTATE is guaranteed to be unique for
#### each LEVEL. (Uses forever incrementing variables ${LAST$LVL} to keep track of
#### which substates to use.)
push_state() {
    varname_or_die push_state "$1" "$2"                                    ## from add_substate
    local _LVL                                                             ## from add_substate
    _incvar "$1"                      # increment level                    ## from add_substate
    _getvar _LVL "$1"                 #   get level value                  ## from add_substate
    int_or_die push_state "$_LVL"                                          ## from add_substate
    _incvar "LAST$_LVL"               # increment last substate            ## from add_substate
    # STATE="$STATE.${LAST$_LVL}"                                          ## from add_substate
    #eval "$2=\"\$$2.\$LAST$_LVL\""    # append last substate to state      ## from add_substate
    # STATE="${STATE}_${LAST$_LVL}"
    eval "$2=\"\${$2}_\${LAST$_LVL}\""  # append last substate to state
    # varname_or_die push_state "$@"
    # local _LVL
    # _incvar "$1"                      # increment level
    # _getvar _LVL "$1"                 #   get level value
    # _incvar "LAST$_LVL"               # increment last substate
    # # STATE="$STATE.${LAST$_LVL}"
    # eval "$2=\"\$${2}_\$LAST$_LVL\""    # append last substate to state
}
# Usage: pop_state LVL STATEVAR
pop_state() {
    varname_or_die pop_state "$@"
    _decvar "$1"                # decrement LVL
    eval "$2=\"\${$2%_*}\""     # remove number from STATE
}
# Usage: inc_state STATEVAR
inc_state() {
    varname_or_die inc_state "$1"
    # case "$STATE" in
    #     *.*) STATE="${STATE%.*}.$((${STATE##*.}+1))";;
    #     *) STATE="$((STATE+1))"
    # esac
    eval "case \"\$$1\" in
        *_*) $1=\"\${$1%_*}_\$((\${$1##*_}+1))\";;
        *) $1=\"\$(($1+1))\"
    esac"
}
# Usage: trim_right SUFFIX VARNAME
#
# Trims all trailing occurrences of SUFFIX off the string in the variable
# VARNAME. If there are multiple occurrences of SUFFIX they are all trimmed
# off. (This applies ${$VARNAME%$SUFFIX} until nothing more is trimmed off.)
trim_right() { varname_or_die trim_right "$2"; _trim_right "$@"; }
_trim_right() {
    local _
    # until _="$STR";STR="${STR%$SUFFIX}";[ "$STR" = "$_" ];do :;done
    eval "until _=\"\$$2\";$2=\"\${$2%\$1}\";[ \"\$$2\" = \"\$_\" ];do :;done"
}

# Usage: parse TOKENIZED
#
# Go through TOKENIZED and create finite-state machine rules suitable for
# parsing a command line. Also checks the validity/nesting of (...) and [...]
# constructs. (Failing if brackets or parentheses are unbalanced.)
#
# The following special characters are recognized:
#   * Group start: '[' or '('
#   * Group end: ']' or ')'
#   * Subgroup separator: '|'
#   * Group repeat: '...'
#
# The beginning of a subgroup can be attached to one or more states (if the
# previous subgroup[s] where optional). The first part of each subgroup is
# therefore connected to all the STARTAT states (space-separated list state
# identifiers). The remaining group states should be the same regardless of
# which 'entry' was taken.
#
# Internals:
#
# LVL is the current level of nesting. GROUPS in the number of the current
# parenthesis. In '()()' GROUPS is 1 and 2, and LVL 0 and 1. In '(())' GROUPS
# is also 1 & 2, but LVL is 0 (outside paren), 1 (inside first paren), and 2
# (inside innermost paren). I.e. GROUPS never decreases, while LVL does. IN is
# the current group we're in, so in '()()' it looks like this '0(1)0(2)0',
# while in '(())' its '0(1(2)1)0'.

#
# GROUP0...N is a pseudo-array containing group stack. It has no meaning
# outside this loop. It contains the group number of the current parenthetical
# group at the end.
#
# TYPE0...N is pseudo-array containing group type. TYPE0='' (because its not
# within brackets), all higher numbers are either ']' or ')' depending on
# whether it's a [...] or (...) group.
#
# FIXME: With [...] some leading and final rules will be needed twice: Implement!
# FIXME: Export _DEBUG_RULES in some 'appropriate' way
# FIXME: Implement finishing rules (instead of final states)
# FIXME: Stop using $IN and $GROUP? (if possible)

# ELLIPSIS RULES
# ==============
# Ellipsis rules are extra rules built up during the processing of each group,
# which are only inserted into the final ruleset if the group in question is
# followed by '...'. They are the purple rules in the finite state machine
# images, and they allow for repetition.
parse() {
    local STARTAT=0                            # startat 'array' length
    local STATE=0 STATECOUNT=0
    local TYPE=''
    local OUT='' END=''
    _DEBUG_STATE=''                            # used in testing
    _DEBUG_GROUP=''
    _DEBUG_LEVEL=''
    _DEBUG_RULES=''
    local LVL=0 GROUPS=0 IN=0 GROUP0=0 TYPE0=''

    # Loop over $@ while setting $A to current arg, and $NEXT to next arg.
    local I=0 A='' NEXT='' PREV='' OLDSTATE='' ENDSTATE='' ELLIPSIS=''
    while I="$(( I + 1 ))"; [ "$I" -le "$#" ]; do
        eval    A="\"\$$I\""                   # current arg
        eval NEXT="\"\$$(( I + 1 ))\""         #   next arg
        append _DEBUG_STATE "$STATE $A"
        append _DEBUG_GROUP "$IN $A"
        append _DEBUG_LEVEL "$LVL $A"
        case "$A" in
            ['(['])                            # start parenthesis or bracket
                _incvar LVL                    #   group level
                _incvar GROUPS                 #   group number
                IN="$GROUPS"                   #   current group number
                local "GROUP$LVL"="$GROUPS"    #   loop stack: group number stack
                case "$A" in                   #   loop stack: group types
                    '(') local "TYPE$LVL"=')' ;;
                    '[') local "TYPE$LVL"=']' ;;
                esac
                _incvar STATECOUNT
                local "BEG$IN"="$STATE"        #   set group start state
                local "END$IN"="$STATECOUNT"   #   set group end state
                #local "ELLIPSIS$IN"=""         #   clear ellipsis rules
                ;;
            '|')                               # pipe
                _getvar STATE "BEG$IN"         #   return to group start state
                ;;
            ['])'])                            # end bracket
                _getvar TYPE "TYPE$LVL"
                [ "$LVL" -le 0    ] && warn "Too many '$A' in rule: $*" && return 1
                [ "$A" != "$TYPE" ] && warn "Missing '$A' in rule (group $IN): $*" && return 1

                #getvar STATE "END$IN"          #     return state to start bracket

                # Apply ellipsis rules if followed by '...'.
                if [ "$NEXT" = '...' ]; then
                    _getvar ELLIPSIS "ELLIPSIS$IN"
                    lfappend "_DEBUG_RULES" "$ELLIPSIS"
                fi

                unset "GROUP$LVL" "TYPE$LVL"   #   remove from group stack
                _decvar LVL                    #   go down one level
                _getvar IN "GROUP$LVL"         #   current group number
                # FIXME: These lines not covered by test cases!! (necessary?)
                case "$NEXT" in [')]'])
                    local "END$IN"="$STATE"
                esac
                ;;
            '...')                             # ellipsis
                # '...' are handled at the end of the ')' / ']' state, and
                # therefore just ignored here.
                ## FIXME: Syntax check: may only come after WORD, ']' or ')'
                ;;
            *)                                 # anything else
                OLDSTATE="$STATE"
                _getvar ENDSTATE "END$IN"
                case "$NEXT" in                #   last in bracket group
                    ['|)]'])                   #     use last state of bracket
                        STATE="$ENDSTATE" ;;
                    *)                         #   otherwise
                        _incvar STATECOUNT     #     increase state by one
                        STATE="$STATECOUNT" ;;
                esac
                lfappend _DEBUG_RULES "$OLDSTATE:$A -> $STATE"
                case "$PREV" in ['[(|'])       # add ellipsis rule
                    lfappend "ELLIPSIS$IN" "$ENDSTATE:$A -> $STATE"
                    echo "ELLIPSIS$IN" "$ENDSTATE:$A -> $STATE"
                esac
                ;;
        esac
        # # DEBUG: Indented parse output
        # local DEBUG_INDENT DEBUG_INDENT_NEXT
        # case "$A" in
        #     '('|'[')                           # start parenthesis or bracket
        #         DEBUG_INDENT_NEXT="    $DEBUG_INDENT" ;;
        #     ']'|')')                           # end bracket
        #         DEBUG_INDENT="${DEBUG_INDENT#    }"
        #         DEBUG_INDENT_NEXT="$DEBUG_INDENT" ;;
        #     '|')                               #   pipe
        #         DEBUG_INDENT_NEXT="$DEBUG_INDENT"
        #         DEBUG_INDENT="${DEBUG_INDENT#  }" ;;
        # esac
        # out "$DEBUG_INDENT>>$A"
        # out "  ${DEBUG_INDENT}LVL:$LVL STATE:$STATE"
        # DEBUG_INDENT="$DEBUG_INDENT_NEXT"
        PREV="$A"
    done
    unset "GROUP0"  # last element of group stack
    unset "TYPE0"
    append _DEBUG_STATE "$STATE"
    append _DEBUG_GROUP "$IN"
    append _DEBUG_LEVEL "$LVL"
    if [ "$LVL" -ne 0 ]; then
        local PAREN; getvar PAREN "TYPE$LVL"
        warn "Missing '$PAREN' at end of rule: $*"
        return 1
    fi
}

################################################################################
##                                                                            ##
##  'Array' stuff                                                             ##
##                                                                            ##
################################################################################

## Some pseudo-array idioms for dash:
##
## Init: Create length counter (nothing more):
##
##     local NAME="0"
##
## Push: Put content into variable named NAME# (where # is the number of the
## element added) then increment length counter by one.
##
##     local "NAME$NAME"="SOMETHING"; $NAME="$(( NAME + 1))"
##
## Pop: First decrement length counter then get and unset the last element.
##
##     NAME="$(( NAME - 1 ))"; eval "VALUE=\"\$NAME$NAME\""; unset "NAME$NAME"
##
## Change value:
##
##     local "NAME$NAME"="NEW VALUE"
##
## Loop over:
##
##     local I=-1
##     while I="$(( I + 1 ))"; [ "$I" -lt "$NAME" ]; do
##         eval "VALUE=\"\$NAME$I\""
##         # do stuff here
##     done
##
## Go through and empty a stack (backwards order).
##
##     while [ "$NAME" -gt 0 ]; do
##         NAME="$(( NAME - 1 ))"; eval "VALUE=\"\$NAME$NAME\""; unset "NAME$NAME"
##         echo "NAME:$NAME"
##         echo "$VALUE"
##     done
##
## Go through and empty a stack from first to last item (array will be invalid
## during traversal but in valid state after loop is done).
##
##     local I=-1
##     while I="$(( I + 1 ))"; [ "$I" -lt "$NAME" ]; do
##         eval "VALUE=\"\$NAME$I\""; unset "NAME$I"
##         echo "NAME:$NAME"
##         echo "$VALUE"
##     done
##     NAME=0
##

ok_varname() {
    local H V
    H="${1:+$1: }"; shift
    for V in "$@"; do
        case "$V" in
            *[!A-Z0-9_]*|[0-9]*)
                warn "${H}Bad variable name '$V'"
                return 1
        esac
    done
    return 0
}

ok_int() {
    local H V
    H="${1:+$1: }"; shift
    for V in "$@"; do
        case "$V" in
            *[!0-9]*)
                warn "${H}Bad integer '$V'"
                return 1
        esac
    done
    return 0
}

# Usage: length ARRAYNAME VARNAME
length() {
    ok_varname length "$@" || return 1         # verify ARRAYNAME & VARNAME
    eval "local _=\${$1_:-0}"                  # get length
    ok_int length "$_" || return 1             # verify length
    eval "$2=\"\$_\""
    return 0
}

# Usage: get ARRAYNAME INDEX VARNAME
#
# Set variable VARNAME to element INDEX of ARRAYNAME.
get() {
    ok_varname get "$1" "$3" || return 1       # verify ARRAYNAME & VARNAME
    ok_int     get "$2"      || return 1       # verify INDEX
    eval "local _=\${$1_:-0}"                  # get length
    ok_int 'get (array length)' "$_" || return 1 # verify length
    [ "$2" -ge "$_" ] && warn "get: Index '$2' too large (max is '$((_ - 1))')" && return 1
    eval "$3=\"\$$1_$2\""
}

# Usage: push ARRAYNAME VALUE
#
# Pushes VALUE onto pseudo-array 'ARRAYNAME'. If called inside a function you
# should also invoke `local "ARRAYNAME$ARRAYNAME"`, before calling this.
push() {
    ok_varname push "$1" || return 1           # verify ARRAYNAME
    eval "local _=\${$1_:-0}"                  # get length
    ok_int push "$_" || return 1               # verify length
    eval "${1}_$_=\"\$2\""                     # set array element
    eval "${1}_=$(( $_ + 1 ))"                 # increase length
    return 0
}

# Usage: pop ARRAYNAME VARNAME
pop() {
    ok_varname pop "$@" || return 1            # verify ARRAYNAME & VARNAME
    eval "local _=\${$1_:-0}"                  # get length
    ok_int pop "$_" || return 1                # verify length
    if [ "$_" -le 0 ]; then
        warn "pop: Array '$1' is empty"
        return 1
    fi
    eval "_=$(( _ - 1 ))"                      # length - 1
    eval "${1}_=\"\$_\""                       # decrease length
    eval "$2=\"\$${1}_$_\""                    # get array element
    unset "${1}_$_"                            # unset last element
    return 0
}

# Usage: dump ARRAYNAME
dump() {
    ok_varname dump "$1" || return 1           # verify ARRAYNAME
    length "$1" _LEN
    local _I=-1 _VALUE=''
    while _I="$(( _I + 1 ))"; [ "$_I" -lt "$_LEN" ]; do
        get "$1" "$_I" _VALUE
        out "$_VALUE"
    done
}

################################################################################
##                                                                            ##
##  Test "Framework"                                                          ##
##                                                                            ##
################################################################################

TESTS_DONE=''
TMPDIR="$(mktemp -dt zdocpt2-XXXXXX)"
TMPNUM="0"
BIN="${0##*/}"
trap "trap - EXIT INT
     [ -d '$TMPDIR' ] && rm -r '$TMPDIR';
     [ \"\$TESTS_DONE\" ] || out '***PREMATURE EXIT! Not all tests ran!';
     exit" EXIT INT

# Usage: tmpfile VARNAME
#
# Sets variable VARNAME to next suitable tempfile.
tmpfile() { setvar "$1" "$TMPDIR/$TMPNUM"; incvar TMPNUM; }

# Usage: printfmultiline FORMAT1 FORMAT2 STUFF
printfml() {
    local FMT="$1" FMT2="$2" X; shift 2
    local LINE IFS='
';  set -- $@                                  # intentionally unquoted
    out '----------------------------------------'
    for LINE in "$@"; do
        printf "$FMT\n" "$LINE"
        FMT="$FMT2"
    done
}

FAILED_TESTS=0
TESTS_COUNT=0
# FIXME: Arg order SHOULD BE: GOT EXPECTED [MESSAGE] (from perl's Tests::More)
# FIXME: Also fix arg order in all invokations
test() {
    local MSG="$1" EXPECTED="$2" GOT="$3" EXTRA="$4"
    TESTS_COUNT="$(( TESTS_COUNT + 1 ))"
    if [ "$GOT" != "$EXPECTED" ]; then
        out "Test failed!!!"
        out "    $MSG"
        [ "$EXTRA" ] && out "    EXTRA   :  $EXTRA"
        local FILE1='' FILE2=''; tmpfile FILE1; tmpfile FILE2
        { out 'EXPECTED'; out "$EXPECTED"; } >"$FILE1"
        { out 'GOT';      out "$GOT";      } >"$FILE2"
        local WIDTH="$(( $(wc -L <"$FILE1") + $(wc -L <"$FILE2") + 8 ))"
        [ "$WIDTH" -gt "$COLUMNS" ] && WIDTH="$COLUMNS"
        diff --width="$WIDTH" --color=always --expand-tabs \
             --side-by-side "$FILE1" "$FILE2" | \
            while IFS='' read -r LINE; do echo "    $LINE\e[m"; done
        out '----------------------------------------'
        #printfml '    EXPECTED: %s' '              %s' "$EXPECTED"
        #printfml '     BUT GOT: %s' '              %s' "$GOT"
        incvar FAILED_TESTS
    fi
}

tests_done() {
    TESTS_DONE=1
    if [ "$FAILED_TESTS" -gt 0 ]; then
        printf '==============================================\n'
        printf '== %-40s ==\n' 'ERRORS!!!!!!!!!!!!11111!!!'
        printf '== %-40s ==\n' "$FAILED_TESTS tests failed!"
        printf '==============================================\n'
        exit 10
    else
        printf "All %s tests passed.\n" "$TESTS_COUNT"
    fi
}

# Usage: dumpenv VARNAME...
#
# Outputs all environment variables to standard output (usin `set`) except
# those specified on the command line. All named variables are locally unset
# before outputting the variables but restored upon exiting the function.
dumpenv() {
    for VAR in "$@"; do
        local "$VAR"
        unset "$VAR"
    done
    set
}

################################################################################
##                                                                            ##
##  Tests                                                                     ##
##                                                                            ##
################################################################################

# FIXME: Since state '1' was eaten here, the last rule output
# FIXME: when we have a case of multiple endings ) )... we must update END$IN for those groups
# FIXME: Implement rules here
INPUT='  (   (   A   )   B   )   ...'
LEVEL='0 ( 1 ( 2 A 2 ) 1 B 1 ) 0 ... 0'
GROUP='0 ( 1 ( 2 A 2 ) 1 B 1 ) 0 ... 0'
STATE='0 ( 0 ( 0 A 2 ) 2 B 1 ) 1 ... 1'; FINAL=1
RULES='0:A -> 2
2:B -> 1
1:A -> 2'
parse $INPUT; RETVAL="$?"                      # intentionally unquoted
test 'Return value'     "0"      "$RETVAL"
test 'Bracket level'    "$LEVEL" "$_DEBUG_LEVEL" "$INPUT"
test 'Group numbers'    "$GROUP" "$_DEBUG_GROUP" "$INPUT"
test 'States'           "$STATE" "$_DEBUG_STATE" "$INPUT"
test 'Rules'            "$RULES" "$_DEBUG_RULES" "$INPUT"

exit
######################################################################
##
##  Test get()
##

# get: Bad 1st arg, ARRAY is a number instead of ARRAY name
tmpfile TMPFILE
ARRAY="original"
get 666 0 ARRAY 2>"$TMPFILE"; RETVAL="$?"
read ERRMSG <"$TMPFILE"
test 'Return value'       "1"                                  "$RETVAL"
test 'Error message'      "$BIN: get: Bad variable name '666'" "$ERRMSG"
test 'Variable unchanged' "$ARRAY"                             "original"

# get: Bad 1st arg, ARRAY with malformed length
tmpfile TMPFILE
ARRAY_=-1                                      # malformed 'array' (bad length)
VARNAME=42
get ARRAY 3 VARNAME 2>"$TMPFILE"; RETVAL="$?"
read ERRMSG <"$TMPFILE"
test 'Return value'       "1"                           "$RETVAL"
test 'Error message'      "$BIN: get (array length): Bad integer '-1'" "$ERRMSG"
test 'Variable unchanged' "$VARNAME"                    "42"

# get: Bad 2nd arg, INDEX is invalid integer
tmpfile TMPFILE
ARRAY="original"          # (a non-array)
VARNAME=42
get ARRAY -1 VARNAME 2>"$TMPFILE"; RETVAL="$?"
read ERRMSG <"$TMPFILE"
test 'Return value'       "1"                           "$RETVAL"
test 'Error message'      "$BIN: get: Bad integer '-1'" "$ERRMSG"
test 'Variable unchanged' "$ARRAY"                      "original"
test 'Variable unchanged' "$VARNAME"                    "42"

# get: Bad 2nd arg, INDEX out of range
tmpfile TMPFILE
ARRAY_=3; ARRAY_0="a"; ARRAY_1="b"; ARRAY_2="c"            # a real 'array'
VARNAME=42
get ARRAY 3 VARNAME 2>"$TMPFILE"; RETVAL="$?"
read ERRMSG <"$TMPFILE"
test 'Return value'       "1"                           "$RETVAL"
test 'Error message'      "$BIN: get: Index '3' too large (max is '2')" "$ERRMSG"
test 'Variable unchanged' "$VARNAME"                    "42"

# get: Bad 3rd arg, VARNAME is a number instead of variable name
tmpfile TMPFILE
ARRAY="original"          # (a non-array)
VARNAME=42
get ARRAY 0 666 2>"$TMPFILE"; RETVAL="$?"
read ERRMSG <"$TMPFILE"
test 'Return value'       "1"                           "$RETVAL"
test 'Error message'      "$BIN: get: Bad variable name '666'" "$ERRMSG"
test 'Variable unchanged' "$ARRAY"                      "original"
test 'Variable unchanged' "$VARNAME"                    "42"

# get: Good args
tmpfile TMPFILE
ARRAY_=3; ARRAY_0="a"; ARRAY_1="b"; ARRAY_2="c"            # a real 'array'
VARNAME=42
get ARRAY 2 VARNAME 2>"$TMPFILE"; RETVAL="$?"
read ERRMSG <"$TMPFILE"
test 'Return value'       "0"                           "$RETVAL"
test 'Variable changed'   "$VARNAME"                    "c"

######################################################################
##
##  Test push(), get(), length() and pop()
##  FIXME: Break these apart and test them more thoroughly

ORG_="$_"
push X a
length X LEN
test 'Length'        '1'     "$LEN"
test '$X_ (length)'  '1'     "$X_"
test '$X_0'          'a'     "$X_0"
test '$X_1'          ''      "$X_1"
test 'leaking $_?'   "$ORG_" "$_"

push X b
length X LEN
test 'Length'        '2'     "$LEN"
test '$X_ (length)'  '2'     "$X_"
test '$X_0'          'a'     "$X_0"
test '$X_1'          'b'     "$X_1"
test '$X_2'          ''      "$X_2"
test 'leaking $_?'   "$ORG_" "$_"

get X 0 VAL
length X LEN
test 'Length'        '2'     "$LEN"
test '$X_ (length)'  '2'     "$X_"
test '$X_0'          'a'     "$X_0"
test '$X_1'          'b'     "$X_1"
test '$X_2'          ''      "$X_2"
test 'leaking $_?'   "$ORG_" "$_"

pop X VALUE
length X LEN
test 'Gotted value'  'b'     "$VALUE"
test 'Length'        '1'     "$LEN"
test '$X_ (length)'  '1'     "$X_"
test '$X_0'          'a'     "$X_0"
test '$X_1'          ''      "$X_1"
test 'leaking $_?'   "$ORG_" "$_"

pop X VALUE
length X LEN
test 'Gotted value'  'a'     "$VALUE"
test 'Length'        '0'     "$LEN"
test '$X_ (length)'  '0'     "$X_"
test '$X_0'          ''      "$X_0"
test '$X_1'          ''      "$X_1"
test 'leaking $_?'   "$ORG_" "$_"

tmpfile TMPFILE
pop X VALUE 2>"$TMPFILE"; RETVAL="$?"          # intentionally unquoted
read ERRMSG <"$TMPFILE"
test 'Return value'  "1" "$RETVAL"
test 'Error message' "$BIN: pop: Array 'X' is empty" "$ERRMSG"

######################################################################
##
##  Test parse() error messages
##

## One ')' too many
INPUT='A )'
tmpfile TMPFILE
parse $INPUT 2>"$TMPFILE"; RETVAL="$?"         # intentionally unquoted
read ERRMSG <"$TMPFILE"
test 'Return value'  "1" "$RETVAL"
test 'Error message' "$BIN: Too many ')' in rule: A )" "$ERRMSG"

## One ']' too many
INPUT='A ]'
tmpfile TMPFILE
parse $INPUT 2>"$TMPFILE"; RETVAL="$?"         # intentionally unquoted
read ERRMSG <"$TMPFILE"
test 'Return value'  "1" "$RETVAL"
test 'Error message' "$BIN: Too many ']' in rule: A ]" "$ERRMSG"

## Missing ')'
INPUT='[ A )'
tmpfile TMPFILE
parse $INPUT 2>"$TMPFILE"; RETVAL="$?"         # intentionally unquoted
read ERRMSG <"$TMPFILE"
test 'Return value'  "1" "$RETVAL"
test 'Error message' "$BIN: Missing ')' in rule (group 1): [ A )" "$ERRMSG"

## Missing ']'
INPUT='( A ]'
tmpfile TMPFILE
parse $INPUT 2>"$TMPFILE"; RETVAL="$?"
read ERRMSG <"$TMPFILE"
test 'Return value'  "1" "$RETVAL"
test 'Error message' "$BIN: Missing ']' in rule (group 1): ( A ]" "$ERRMSG"

## Missing ']'
INPUT='( A'
tmpfile TMPFILE
parse $INPUT 2>"$TMPFILE"; RETVAL="$?"
read ERRMSG <"$TMPFILE"
test 'Return value'  "1" "$RETVAL"
test 'Error message' "$BIN: Missing ')' at end of rule: ( A" "$ERRMSG"

######################################################################
##
##  Test Actual Results
##

INPUT='  A'
LEVEL='0 A 0'
GROUP='0 A 0'
STATE='0 A 1'; FINAL='1'
RULES='0:A -> 1'
parse $INPUT; RETVAL="$?"                      # intentionally unquoted
test 'Return value'     "0"      "$RETVAL"
test 'Bracket level'    "$LEVEL" "$_DEBUG_LEVEL" "$INPUT"
test 'Group numbers'    "$GROUP" "$_DEBUG_GROUP" "$INPUT"
test 'State numbers'    "$STATE" "$_DEBUG_STATE" "$INPUT"
test 'Rules'            "$RULES" "$_DEBUG_RULES" "$INPUT"

INPUT='  A   B'
LEVEL='0 A 0 B 0'
GROUP='0 A 0 B 0'
STATE='0 A 1 B 2'; FINAL='2'
RULES='0:A -> 1
1:B -> 2'
parse $INPUT; RETVAL="$?"                      # intentionally unquoted
test 'Return value'     "0"      "$RETVAL"
test 'Bracket level'    "$LEVEL" "$_DEBUG_LEVEL" "$INPUT"
test 'Group numbers'    "$GROUP" "$_DEBUG_GROUP" "$INPUT"
test 'State numbers'    "$STATE" "$_DEBUG_STATE" "$INPUT"
test 'Rules'            "$RULES" "$_DEBUG_RULES" "$INPUT"

INPUT='  (   A   )   B'
LEVEL='0 ( 1 A 1 ) 0 B 0'
GROUP='0 ( 1 A 1 ) 0 B 0'
STATE='0 ( 0 A 1 ) 1 B 2'; FINAL='2'
RULES='0:A -> 1
1:B -> 2'
parse $INPUT; RETVAL="$?"                      # intentionally unquoted
test 'Return value'     "0"      "$RETVAL"
test 'Bracket level'    "$LEVEL" "$_DEBUG_LEVEL" "$INPUT"
test 'Group numbers'    "$GROUP" "$_DEBUG_GROUP" "$INPUT"
test 'State numbers'    "$STATE" "$_DEBUG_STATE" "$INPUT"
test 'Rules'            "$RULES" "$_DEBUG_RULES" "$INPUT"

INPUT='  (   A   )   (   B   )'
LEVEL='0 ( 1 A 1 ) 0 ( 1 B 1 ) 0'
GROUP='0 ( 1 A 1 ) 0 ( 2 B 2 ) 0'
STATE='0 ( 0 A 1 ) 1 ( 1 B 2 ) 2'; FINAL='2'
RULES='0:A -> 1
1:B -> 2'
parse $INPUT; RETVAL="$?"                      # intentionally unquoted
test 'Return value'     "0"      "$RETVAL"
test 'Bracket level'    "$LEVEL" "$_DEBUG_LEVEL" "$INPUT"
test 'Group numbers'    "$GROUP" "$_DEBUG_GROUP" "$INPUT"
test 'State numbers'    "$STATE" "$_DEBUG_STATE" "$INPUT"
test 'Rules'            "$RULES" "$_DEBUG_RULES" "$INPUT"

INPUT='  (   (   A   )   B   )'
LEVEL='0 ( 1 ( 2 A 2 ) 1 B 1 ) 0'
GROUP='0 ( 1 ( 2 A 2 ) 1 B 1 ) 0'
STATE='0 ( 0 ( 0 A 2 ) 2 B 1 ) 1'; FINAL='1'
RULES='0:A -> 2
2:B -> 1'
parse $INPUT; RETVAL="$?"                      # intentionally unquoted
test 'Return value'     "0"      "$RETVAL"
test 'Bracket level'    "$LEVEL" "$_DEBUG_LEVEL" "$INPUT"
test 'Group numbers'    "$GROUP" "$_DEBUG_GROUP" "$INPUT"
test 'State numbers'    "$STATE" "$_DEBUG_STATE" "$INPUT"
test 'Rules'            "$RULES" "$_DEBUG_RULES" "$INPUT"

INPUT='  (   A   (   B   )   )'
LEVEL='0 ( 1 A 1 ( 2 B 2 ) 1 ) 0'
GROUP='0 ( 1 A 1 ( 2 B 2 ) 1 ) 0'
STATE='0 ( 0 A 2 ( 2 B 3 ) 3 ) 3'; FINAL='3' # (state 1 never used)
RULES='0:A -> 2
2:B -> 3'
parse $INPUT; RETVAL="$?"                      # intentionally unquoted
test 'Return value'     "0"      "$RETVAL"
test 'Bracket level'    "$LEVEL" "$_DEBUG_LEVEL" "$INPUT"
test 'Group numbers'    "$GROUP" "$_DEBUG_GROUP" "$INPUT"
test 'State numbers'    "$STATE" "$_DEBUG_STATE" "$INPUT"
test 'Rules'            "$RULES" "$_DEBUG_RULES" "$INPUT"

INPUT='  (   A   (   B   (   C   )   )   )'
LEVEL='0 ( 1 A 1 ( 2 B 2 ( 3 C 3 ) 2 ) 1 ) 0'
GROUP='0 ( 1 A 1 ( 2 B 2 ( 3 C 3 ) 2 ) 1 ) 0'
STATE='0 ( 0 A 2 ( 2 B 4 ( 4 C 5 ) 5 ) 5 ) 5'; FINAL='3' # (state 1 & 3 never used)
RULES='0:A -> 2
2:B -> 4
4:C -> 5'
parse $INPUT; RETVAL="$?"                      # intentionally unquoted
test 'Return value'     "0"      "$RETVAL"
test 'Bracket level'    "$LEVEL" "$_DEBUG_LEVEL" "$INPUT"
test 'Group numbers'    "$GROUP" "$_DEBUG_GROUP" "$INPUT"
test 'State numbers'    "$STATE" "$_DEBUG_STATE" "$INPUT"
test 'Rules'            "$RULES" "$_DEBUG_RULES" "$INPUT"

INPUT='  (   A   B   C   |   D   E   F   |   G   H   I   )   X'
LEVEL='0 ( 1 A 1 B 1 C 1 | 1 D 1 E 1 F 1 | 1 G 1 H 1 I 1 ) 0 X 0'
GROUP='0 ( 1 A 1 B 1 C 1 | 1 D 1 E 1 F 1 | 1 G 1 H 1 I 1 ) 0 X 0'
STATE='0 ( 0 A 2 B 3 C 1 | 0 D 4 E 5 F 1 | 0 G 6 H 7 I 1 ) 1 X 8'
RULES='0:A -> 2
2:B -> 3
3:C -> 1
0:D -> 4
4:E -> 5
5:F -> 1
0:G -> 6
6:H -> 7
7:I -> 1
1:X -> 8'
parse $INPUT; RETVAL="$?"                      # intentionally unquoted
test 'Return value'     "0"      "$RETVAL"
test 'Bracket level'    "$LEVEL" "$_DEBUG_LEVEL" "$INPUT"
test 'Group numbers'    "$GROUP" "$_DEBUG_GROUP" "$INPUT"
test 'State numbers'    "$STATE" "$_DEBUG_STATE" "$INPUT"
test 'Rules'            "$RULES" "$_DEBUG_RULES" "$INPUT"

INPUT='  [   A   B   C   |   D   E   F   |   G   H   I   ]   X'
LEVEL='0 [ 1 A 1 B 1 C 1 | 1 D 1 E 1 F 1 | 1 G 1 H 1 I 1 ] 0 X 0'
GROUP='0 [ 1 A 1 B 1 C 1 | 1 D 1 E 1 F 1 | 1 G 1 H 1 I 1 ] 0 X 0'
STATE='0 [ 0 A 2 B 3 C 1 | 0 D 4 E 5 F 1 | 0 G 6 H 7 I 1 ] 1 X 8'
## FIXME: These rules should also account for the [...]
RULES='0:A -> 2
2:B -> 3
3:C -> 1
0:D -> 4
4:E -> 5
5:F -> 1
0:G -> 6
6:H -> 7
7:I -> 1
1:X -> 8'
parse $INPUT; RETVAL="$?"                      # intentionally unquoted
test 'Return value'     "0"      "$RETVAL"
test 'Bracket level'    "$LEVEL" "$_DEBUG_LEVEL" "$INPUT"
test 'Group numbers'    "$GROUP" "$_DEBUG_GROUP" "$INPUT"
test 'State numbers'    "$STATE" "$_DEBUG_STATE" "$INPUT"
test 'Rules'            "$RULES" "$_DEBUG_RULES" "$INPUT"

INPUT='  [   A   B   C   |   D   E   F   |   G   H   I   ]   ...  X'
LEVEL='0 [ 1 A 1 B 1 C 1 | 1 D 1 E 1 F 1 | 1 G 1 H 1 I 1 ] 0 ... 0 X 0'
GROUP='0 [ 1 A 1 B 1 C 1 | 1 D 1 E 1 F 1 | 1 G 1 H 1 I 1 ] 0 ... 0 X 0'
STATE='0 [ 0 A 2 B 3 C 1 | 0 D 4 E 5 F 1 | 0 G 6 H 7 I 1 ] 1 ... 1 X 8'
## FIXME: These rules should also account for the [...]
## Ellipsis is corresponds to rules: '1:A -> 2', '1:D -> 4' and '1:G -> 6'.
unset X                                        # ugly in-string coments
RULES="0:A -> 2
2:B -> 3
3:C -> 1
0:D -> 4
4:E -> 5
5:F -> 1
0:G -> 6
6:H -> 7
7:I -> 1
1:A -> 2${X:+                                  # ellipsis rule}
1:D -> 4${X:+                                  # ellipsis rule}
1:G -> 6${X:+                                  # ellipsis rule}
1:X -> 8"
parse $INPUT; RETVAL="$?"                      # intentionally unquoted
test 'Return value'     "0"      "$RETVAL"
test 'Bracket level'    "$LEVEL" "$_DEBUG_LEVEL" "$INPUT"
test 'Group numbers'    "$GROUP" "$_DEBUG_GROUP" "$INPUT"
test 'State numbers'    "$STATE" "$_DEBUG_STATE" "$INPUT"
test 'Rules'            "$RULES" "$_DEBUG_RULES" "$INPUT"

INPUT='  (   A   )'
LEVEL='0 ( 1 A 1 ) 0'
GROUP='0 ( 1 A 1 ) 0'
STATE='0 ( 0 A 1 ) 1'; FINAL="1"
RULES='0:A -> 1'
parse $INPUT; RETVAL="$?"                      # intentionally unquoted
test 'Return value'     "0"      "$RETVAL"
test 'Bracket level'    "$LEVEL" "$_DEBUG_LEVEL" "$INPUT"
test 'Group numbers'    "$GROUP" "$_DEBUG_GROUP" "$INPUT"
test 'States'           "$STATE" "$_DEBUG_STATE" "$INPUT"
test 'Rules'            "$RULES" "$_DEBUG_RULES" "$INPUT"

INPUT='  (   A   )   (   B   )'
LEVEL='0 ( 1 A 1 ) 0 ( 1 B 1 ) 0'
GROUP='0 ( 1 A 1 ) 0 ( 2 B 2 ) 0'
STATE='0 ( 0 A 1 ) 1 ( 1 B 2 ) 2'; FINAL="2"
RULES='0:A -> 1
1:B -> 2'
parse $INPUT; RETVAL="$?"                      # intentionally unquoted
test 'Return value'     "0"      "$RETVAL"
test 'Bracket level'    "$LEVEL" "$_DEBUG_LEVEL" "$INPUT"
test 'Group numbers'    "$GROUP" "$_DEBUG_GROUP" "$INPUT"
test 'States'           "$STATE" "$_DEBUG_STATE" "$INPUT"
test 'Rules'            "$RULES" "$_DEBUG_RULES" "$INPUT"

INPUT='  (   A   (   B   )   )'
LEVEL='0 ( 1 A 1 ( 2 B 2 ) 1 ) 0'
GROUP='0 ( 1 A 1 ( 2 B 2 ) 1 ) 0'
STATE='0 ( 0 A 2 ( 2 B 3 ) 3 ) 3'; FINAL="2"
RULES='0:A -> 2
2:B -> 3'
parse $INPUT; RETVAL="$?"                      # intentionally unquoted
test 'Return value'     "0"      "$RETVAL"
test 'Bracket level'    "$LEVEL" "$_DEBUG_LEVEL" "$INPUT"
test 'Group numbers'    "$GROUP" "$_DEBUG_GROUP" "$INPUT"
test 'States'           "$STATE" "$_DEBUG_STATE" "$INPUT"
test 'Rules'            "$RULES" "$_DEBUG_RULES" "$INPUT"

INPUT='  (   (   A   B   )   )'
LEVEL='0 ( 1 ( 2 A 2 B 2 ) 1 ) 0'
GROUP='0 ( 1 ( 2 A 2 B 2 ) 1 ) 0'
STATE='0 ( 0 ( 0 A 3 B 2 ) 2 ) 2'; FINAL="2"
RULES='0:A -> 3
3:B -> 2'
parse $INPUT; RETVAL="$?"                      # intentionally unquoted
test 'Return value'     "0"      "$RETVAL"
test 'Bracket level'    "$LEVEL" "$_DEBUG_LEVEL" "$INPUT"
test 'Group numbers'    "$GROUP" "$_DEBUG_GROUP" "$INPUT"
test 'States'           "$STATE" "$_DEBUG_STATE" "$INPUT"
test 'Rules'            "$RULES" "$_DEBUG_RULES" "$INPUT"

INPUT='  (   (   A   )   B   )'
LEVEL='0 ( 1 ( 2 A 2 ) 1 B 1 ) 0'
GROUP='0 ( 1 ( 2 A 2 ) 1 B 1 ) 0'
STATE='0 ( 0 ( 0 A 2 ) 2 B 1 ) 1'; FINAL="2"
RULES='0:A -> 2
2:B -> 1'
parse $INPUT; RETVAL="$?"                      # intentionally unquoted
test 'Return value'     "0"      "$RETVAL"
test 'Bracket level'    "$LEVEL" "$_DEBUG_LEVEL" "$INPUT"
test 'Group numbers'    "$GROUP" "$_DEBUG_GROUP" "$INPUT"
test 'States'           "$STATE" "$_DEBUG_STATE" "$INPUT"
test 'Rules'            "$RULES" "$_DEBUG_RULES" "$INPUT"

INPUT='  [   A   ]'
LEVEL='0 [ 1 A 1 ] 0'
GROUP='0 [ 1 A 1 ] 0'
STATE='0 [ 0 A 1 ] 1'; FINAL="0 1"
## FIXME: These rules should also account for the [...]
RULES='0:A -> 1'
parse $INPUT; RETVAL="$?"                      # intentionally unquoted
test 'Return value'     "0"      "$RETVAL"
test 'Bracket level'    "$LEVEL" "$_DEBUG_LEVEL" "$INPUT"
test 'Group numbers'    "$GROUP" "$_DEBUG_GROUP" "$INPUT"
test 'States'           "$STATE" "$_DEBUG_STATE" "$INPUT"
test 'Rules'            "$RULES" "$_DEBUG_RULES" "$INPUT"

INPUT='  (   A   |   B   )'
LEVEL='0 ( 1 A 1 | 1 B 1 ) 0'
GROUP='0 ( 1 A 1 | 1 B 1 ) 0'
STATE='0 ( 0 A 1 | 0 B 1 ) 1'; FINAL=1
RULES='0:A -> 1
0:B -> 1'
parse $INPUT; RETVAL="$?"                      # intentionally unquoted
test 'Return value'     "0"      "$RETVAL"
test 'Bracket level'    "$LEVEL" "$_DEBUG_LEVEL" "$INPUT"
test 'Group numbers'    "$GROUP" "$_DEBUG_GROUP" "$INPUT"
test 'States'           "$STATE" "$_DEBUG_STATE" "$INPUT"
test 'Rules'            "$RULES" "$_DEBUG_RULES" "$INPUT"

INPUT='  A ... B'
LEVEL='0 A 0 ... 0 B 0'
GROUP='0 A 0 ... 0 B 0'
STATE='0 A 1 ... 1 B 2'; FINAL=2
RULES='0:A -> 1
1:B -> 2'
parse $INPUT; RETVAL="$?"                      # intentionally unquoted
test 'Return value'     "0"      "$RETVAL"
test 'Bracket level'    "$LEVEL" "$_DEBUG_LEVEL" "$INPUT"
test 'Group numbers'    "$GROUP" "$_DEBUG_GROUP" "$INPUT"
test 'States'           "$STATE" "$_DEBUG_STATE" "$INPUT"
test 'Rules'            "$RULES" "$_DEBUG_RULES" "$INPUT"

## FIXME: NAKED ELLIPSIS (without preceeding parenthesis group)
# INPUT='  A   ...   B'
# LEVEL='0 A 0 ... 0 B 0'
# GROUP='0 A 0 ... 0 B 0'
# STATE='0 A 1 ... 1 B 2'; FINAL=2
# RULES='0:A -> 1
# 1:B -> 2
# 1:A -> 1'
# parse $INPUT; RETVAL="$?"                      # intentionally unquoted
# test 'Return value'     "0"      "$RETVAL"
# test 'Bracket level'    "$LEVEL" "$_DEBUG_LEVEL" "$INPUT"
# test 'Group numbers'    "$GROUP" "$_DEBUG_GROUP" "$INPUT"
# test 'States'           "$STATE" "$_DEBUG_STATE" "$INPUT"
# test 'Rules'            "$RULES" "$_DEBUG_RULES" "$INPUT"

INPUT='  (   A   ) ... B'
LEVEL='0 ( 1 A 1 ) 0 ... 0 B 0'
GROUP='0 ( 1 A 1 ) 0 ... 0 B 0'
STATE='0 ( 0 A 1 ) 1 ... 1 B 2'; FINAL=2
RULES='0:A -> 1
1:A -> 1
1:B -> 2'
parse $INPUT; RETVAL="$?"                      # intentionally unquoted
test 'Return value'     "0"      "$RETVAL"
test 'Bracket level'    "$LEVEL" "$_DEBUG_LEVEL" "$INPUT"
test 'Group numbers'    "$GROUP" "$_DEBUG_GROUP" "$INPUT"
test 'States'           "$STATE" "$_DEBUG_STATE" "$INPUT"
test 'Rules'            "$RULES" "$_DEBUG_RULES" "$INPUT"

INPUT='  (   A   B   )   ...'
LEVEL='0 ( 1 A 1 B 1 ) 0 ... 0'
GROUP='0 ( 1 A 1 B 1 ) 0 ... 0'
STATE='0 ( 0 A 2 B 1 ) 1 ... 1'; FINAL=2
RULES='0:A -> 2
2:B -> 1
1:A -> 2'
parse $INPUT; RETVAL="$?"                      # intentionally unquoted
test 'Return value'     "0"      "$RETVAL"
test 'Bracket level'    "$LEVEL" "$_DEBUG_LEVEL" "$INPUT"
test 'Group numbers'    "$GROUP" "$_DEBUG_GROUP" "$INPUT"
test 'States'           "$STATE" "$_DEBUG_STATE" "$INPUT"
test 'Rules'            "$RULES" "$_DEBUG_RULES" "$INPUT"

INPUT='  (   A   )   (   B   )   ...'
LEVEL='0 ( 1 A 1 ) 0 ( 1 B 1 ) 0 ... 0'
GROUP='0 ( 1 A 1 ) 0 ( 2 B 2 ) 0 ... 0'
STATE='0 ( 0 A 1 ) 1 ( 1 B 2 ) 2 ... 2'; FINAL=2
RULES='0:A -> 1
1:B -> 2
2:B -> 2'
parse $INPUT; RETVAL="$?"                      # intentionally unquoted
test 'Return value'     "0"      "$RETVAL"
test 'Bracket level'    "$LEVEL" "$_DEBUG_LEVEL" "$INPUT"
test 'Group numbers'    "$GROUP" "$_DEBUG_GROUP" "$INPUT"
test 'States'           "$STATE" "$_DEBUG_STATE" "$INPUT"
test 'Rules'            "$RULES" "$_DEBUG_RULES" "$INPUT"

# FIXME: Since state '1' was eaten here, the last rule output
# FIXME: When we have a case of multiple endings ) )... we must update END$IN for those groups
# FIXME: Implement rules here
INPUT='  (   A   (   B   )   )   ...'
LEVEL='0 ( 1 A 1 ( 2 B 2 ) 1 ) 0 ... 0'
GROUP='0 ( 1 A 1 ( 2 B 2 ) 1 ) 0 ... 0'
STATE='0 ( 0 A 2 ( 2 B 3 ) 3 ) 3 ... 3'; FINAL=3
RULES='0:A -> 2
2:B -> 3
3:A -> 2'
parse $INPUT; RETVAL="$?"                      # intentionally unquoted
test 'Return value'     "0"      "$RETVAL"
test 'Bracket level'    "$LEVEL" "$_DEBUG_LEVEL" "$INPUT"
test 'Group numbers'    "$GROUP" "$_DEBUG_GROUP" "$INPUT"
test 'States'           "$STATE" "$_DEBUG_STATE" "$INPUT"
#test 'Rules'            "$RULES" "$_DEBUG_RULES" "$INPUT"

# FIXME: Since state '1' was eaten here, the last rule output
# FIXME: when we have a case of multiple endings ) )... we must update END$IN for those groups
# FIXME: Implement rules here
INPUT='  (   A   (   B   (   C   )   )   )   ...'
LEVEL='0 ( 1 A 1 ( 2 B 2 ( 3 C 3 ) 2 ) 1 ) 0 ... 0'
GROUP='0 ( 1 A 1 ( 2 B 2 ( 3 C 3 ) 2 ) 1 ) 0 ... 0'
STATE='0 ( 0 A 2 ( 2 B 4 ( 4 C 5 ) 5 ) 5 ) 5 ... 5'; FINAL=5
# RULES='0:A -> 2
# 2:B -> 3
# 3:A -> 2'
parse $INPUT; RETVAL="$?"                      # intentionally unquoted
test 'Return value'     "0"      "$RETVAL"
test 'Bracket level'    "$LEVEL" "$_DEBUG_LEVEL" "$INPUT"
test 'Group numbers'    "$GROUP" "$_DEBUG_GROUP" "$INPUT"
test 'States'           "$STATE" "$_DEBUG_STATE" "$INPUT"
# test 'Rules'            "$RULES" "$_DEBUG_RULES" "$INPUT"

# FIXME: Since state '1' was eaten here, the last rule output
# FIXME: when we have a case of multiple endings ) )... we must update END$IN for those groups
# FIXME: Implement rules here
INPUT='  (   (   A   )   B   )   ...'
LEVEL='0 ( 1 ( 2 A 2 ) 1 B 1 ) 0 ... 0'
GROUP='0 ( 1 ( 2 A 2 ) 1 B 1 ) 0 ... 0'
STATE='0 ( 0 ( 0 A 2 ) 2 B 1 ) 1 ... 1'; FINAL=1
RULES='0:A -> 2
2:B -> 1
1:A -> 2'
parse $INPUT; RETVAL="$?"                      # intentionally unquoted
test 'Return value'     "0"      "$RETVAL"
test 'Bracket level'    "$LEVEL" "$_DEBUG_LEVEL" "$INPUT"
test 'Group numbers'    "$GROUP" "$_DEBUG_GROUP" "$INPUT"
test 'States'           "$STATE" "$_DEBUG_STATE" "$INPUT"
test 'Rules'            "$RULES" "$_DEBUG_RULES" "$INPUT"

## FIXME: Add test cases for
##     A B ...
##     ( ( A ) B ) ...




######################################################################
##
##  Tests from Finite State Automaton Images
##

INPUT='  (   A   B   C   |   D   E   F   |   G   H   I   )'
LEVEL='0 ( 1 A 1 B 1 C 1 | 1 D 1 E 1 F 1 | 1 G 1 H 1 I 1 ) 0'
GROUP='0 ( 1 A 1 B 1 C 1 | 1 D 1 E 1 F 1 | 1 G 1 H 1 I 1 ) 0'
STATE='0 ( 0 A 2 B 3 C 1 | 0 D 4 E 5 F 1 | 0 G 6 H 7 I 1 ) 1'; FINAL=1
RULES='0:A -> 2
2:B -> 3
3:C -> 1
0:D -> 4
4:E -> 5
5:F -> 1
0:G -> 6
6:H -> 7
7:I -> 1'
#1: -> X'                                      # FIXME: eol (or next grouping)
# FIXME: Code should produce the (above) finishing state
parse $INPUT; RETVAL="$?"                      # intentionally unquoted
test 'Return value'     "0"      "$RETVAL"
test 'Bracket level'    "$LEVEL" "$_DEBUG_LEVEL" "$INPUT"
test 'Group numbers'    "$GROUP" "$_DEBUG_GROUP" "$INPUT"
test 'States'           "$STATE" "$_DEBUG_STATE" "$INPUT"
test 'Rules'            "$RULES" "$_DEBUG_RULES" "$INPUT"

INPUT='  [   A   B   C   |   D   E   F   |   G   H   I   ]'
LEVEL='0 [ 1 A 1 B 1 C 1 | 1 D 1 E 1 F 1 | 1 G 1 H 1 I 1 ] 0'
GROUP='0 [ 1 A 1 B 1 C 1 | 1 D 1 E 1 F 1 | 1 G 1 H 1 I 1 ] 0'
STATE='0 [ 0 A 2 B 3 C 1 | 0 D 4 E 5 F 1 | 0 G 6 H 7 I 1 ] 1'; FINAL="0 1"
RULES='0:A -> 2
2:B -> 3
3:C -> 1
0:D -> 4
4:E -> 5
5:F -> 1
0:G -> 6
6:H -> 7
7:I -> 1'
#1: -> X                                       # FIXME: eol (or next grouping)
#0: -> X'                                      # FIXME: eol (or next grouping)
# FIXME: Code should produce the (above) finishing states
parse $INPUT; RETVAL="$?"                      # intentionally unquoted
test 'Return value'     "0"      "$RETVAL"
test 'Bracket level'    "$LEVEL" "$_DEBUG_LEVEL" "$INPUT"
test 'Group numbers'    "$GROUP" "$_DEBUG_GROUP" "$INPUT"
test 'States'           "$STATE" "$_DEBUG_STATE" "$INPUT"
test 'Rules'            "$RULES" "$_DEBUG_RULES" "$INPUT"

INPUT='  (   A   B   C   |   D   E   F   |   G   H   I   )   ...'
LEVEL='0 ( 1 A 1 B 1 C 1 | 1 D 1 E 1 F 1 | 1 G 1 H 1 I 1 ) 0 ... 0'
GROUP='0 ( 1 A 1 B 1 C 1 | 1 D 1 E 1 F 1 | 1 G 1 H 1 I 1 ) 0 ... 0'
STATE='0 ( 0 A 2 B 3 C 1 | 0 D 4 E 5 F 1 | 0 G 6 H 7 I 1 ) 1 ... 1'; FINAL=1
unset X                                        # ugly in-string coments
RULES="0:A -> 2
2:B -> 3
3:C -> 1
0:D -> 4
4:E -> 5
5:F -> 1
0:G -> 6
6:H -> 7
7:I -> 1
1:A -> 2${X:+                                  # ellipsis rule}
1:D -> 4${X:+                                  # ellipsis rule}
1:G -> 6${X:+                                  # ellipsis rule}"
#1: -> X'                                      # FIXME: eol (or next grouping)
# FIXME: Code should produce the (above) finishing state
parse $INPUT; RETVAL="$?"                      # intentionally unquoted
test 'Return value'     "0"      "$RETVAL"
test 'Bracket level'    "$LEVEL" "$_DEBUG_LEVEL" "$INPUT"
test 'Group numbers'    "$GROUP" "$_DEBUG_GROUP" "$INPUT"
test 'States'           "$STATE" "$_DEBUG_STATE" "$INPUT"
test 'Rules'            "$RULES" "$_DEBUG_RULES" "$INPUT"

INPUT='  [   A   B   C   |   D   E   F   |   G   H   I   ] ...'
LEVEL='0 [ 1 A 1 B 1 C 1 | 1 D 1 E 1 F 1 | 1 G 1 H 1 I 1 ] 0 ... 0'
GROUP='0 [ 1 A 1 B 1 C 1 | 1 D 1 E 1 F 1 | 1 G 1 H 1 I 1 ] 0 ... 0'
STATE='0 [ 0 A 2 B 3 C 1 | 0 D 4 E 5 F 1 | 0 G 6 H 7 I 1 ] 1 ... 1'; FINAL="0 1"
unset X                                        # ugly in-string coments
RULES="0:A -> 2
2:B -> 3
3:C -> 1
0:D -> 4
4:E -> 5
5:F -> 1
0:G -> 6
6:H -> 7
7:I -> 1
1:A -> 2${X:+                                  # ellipsis rule}
1:D -> 4${X:+                                  # ellipsis rule}
1:G -> 6${X:+                                  # ellipsis rule}"
#1: -> X                                       # FIXME: eol (or next grouping)
#0: -> X'                                      # FIXME: eol (or next grouping)
# FIXME: Code should produce the (above) finishing state
BEGENV="$(dumpenv \
    _DEBUG_RULES _DEBUG_STATE _DEBUG_GROUP _DEBUG_LEVEL \
    BEGENV ENDENV TESTS_COUNT)" # expect
parse $INPUT; RETVAL="$?"                      # intentionally unquoted
test 'Return value'     "0"      "$RETVAL"
test 'Bracket level'    "$LEVEL" "$_DEBUG_LEVEL" "$INPUT"
test 'Group numbers'    "$GROUP" "$_DEBUG_GROUP" "$INPUT"
test 'States'           "$STATE" "$_DEBUG_STATE" "$INPUT"
test 'Rules'            "$RULES" "$_DEBUG_RULES" "$INPUT"
ENDENV="$(dumpenv \
    _DEBUG_RULES _DEBUG_STATE _DEBUG_GROUP _DEBUG_LEVEL \
    BEGENV ENDENV TESTS_COUNT)" # got
test 'Variable leakage' "$BEGENV" "$ENDENV"      "$INPUT"

tests_done
exit


    ARGS='  [ NAME ]'
EXPECTED='0 [ 0 NAME 0 ] 0'
out $ARGS           # intentionally unquoted
parse $ARGS      # intentionally unquoted

    ARGS='  (   (   A   (   B   |   C   [   D   ]   )   )   |   (   E   )   (   F   )   )'
EXPECTED='0 ( 0 ( 0 A 1 ( 1 B 2 | 1 C 3 [ 3 D 3 ] 3 ) 3 ) 3 | 0 ( 0 E 4 ) 4 ( 4 F 5 ) 5 ) 5'
#         0 ( 0 ( 0   1 ( 1   2 | 1   3 [ 3   3 ] 3 ) 3 ) 3 | 0 ( 0   4 ) 4 ( 4   5 ) 5 ) 5
# LEVEL:    1   2   2   3   3   3   3   4   4   4   3   2   1   2   2   2   2   2   2   1
# START:    0   0       1               3                       2       2   2       2   1

# before '|' = set group endstate
#   if type bracket = endstate = startstate
#   if type paren   = endstate = next state


out $ARGS        # intentionally unquoted
parse $ARGS   # intentionally unquoted

echo ">$BEG2<"

#[eof]

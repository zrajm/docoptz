#!/bin/sh

#DEBUG=1
if [ "$DEBUG" ]; then
    DEBUG() { {
        printf '%s\n' "$1"; shift
        printf '    %s\n' "$@"
    } >&2; }
else
    DEBUG() { :; }
fi

################################################################################

out() { printf '%s\n' "$*"; }
die() {
    printf '%s: %s\n' "${0##*/}" "$*"
    exit 5
}
varname_or_die() {
    H="${1:+$1: }"; shift
    for V in "$@"; do
        case "$V" in *[!A-Z0-9_]*|[0-9]*) die "${H}Bad varname '$V'"; esac
    done
}
int_or_die() {
    H="${1:+$1: }"; shift
    for V in "$@"; do
        case "$V" in *[!0-9]*) die "${H}Bad integer '$V'"; esac
    done
}
# Usage: getvar VARNAME1 VARNAME2
#
# Variable VARNAME1 is set to whatever variable VARNAME2 contains.
getvar() { varname_or_die getvar "$1" "$2"; _getvar "$@"; }
_getvar() { eval "$1=\"\$$2\""; }

# Usage: getvar VARNAME1 VARNAME2
#
# Variable VARNAME1 is set to whatever variable VARNAME2 contains.
getint() { varname_or_die getint "$1" "$2"; _getint "$@"; }
_getint() {
    eval "$1=\"\$$2\"";
    int_or_die getint "$1";
}

# Usage: append VARNAME STRING
#
# Append STRING to VARNAME with a space inbetween (unless VARNAME is empty, in
# which case no space is inserted in front of STRING).
append() {
    varname_or_die append "$1";
    # VARNAME="${VARNAME:+$VARNAME }$2"
    eval "$1=\"\${$1:+\$$1 }\$2\""
}

# Usage: setvar VARNAME VALUE
#
# Set variable VARNAME to the specified value.
setvar() { varname_or_die setvar "$1"; _setvar "$@"; }
_setvar() { eval "$1=\"\$2\""; }

# Usage: incvar VARNAME
#
# Sets variable VARNAME to 0 if unset, otherwise increment VARNAME by one.
incvar() { varname_or_die incvar "$1"; _incvar "$@"; }
_incvar() { eval "$1=\"\$((\${$1:--1} + 1))\""; } #VAR="$((${VAR:--1} + 1))"

# Usage: decvar VARNAME
#
# Sets variable VARNAME to 0 if unset, otherwise decrement VARNAME by one.
decvar() { varname_or_die decvar "$1"; _decvar "$@"; }
_decvar() { _setvar "$1" "$(($1 - 1))"; }

# Usage: VARNAME VALUE
#
# Set varible VARNAME to VALUE, except remove all trailing '.0' first.
stripzeroes() {
    #R="$STATE"
    #while [ "$R" != "${R%.0}" ]; do R="${R%.0}"; done
    eval "$1=\"\$2\";
    while [ \"\$$1\" != \"\${$1%.0}\" ]; do $1=\"\${$1%.0}\"; done"
}

# Usage: increment_state STATE
#
# Where STATE is a number like '0' or '1.2' or '0.2.3'. Increments last digit
# of state by one.
increment_state() {
    # case "$STATE" in
    #     *.*) STATE="${STATE%.*}.$((${STATE##*.}+1))";;
    #     *) STATE="$((STATE+1))"
    # esac
    varname_or_die increment_state "$1"
    eval "case \"\$$1\" in
        *.*) $1=\"\${$1%.*}.\$((\${$1##*.}+1))\";;
        *) $1=\"\$(($1+1))\"
    esac"
}

# Usage: LEVELVAR STATEVAR
#
# Goes one level deeper into hierarchy, by adding one to LEVELVAR and appending
# a '.SUBSTATE' number to STATEVAR. SUBSTATE is guaranteed to be unique for
# each LEVEL. (Uses forever incrementing variables ${LAST$LVL} to keep track of
# which substates to use.)
add_substate() {
    varname_or_die add_substate "$1" "$2"
    local _LVL
    _incvar "$1"                      # increment level
    _getvar _LVL "$1"                 #   get level value
    int_or_die add_substate "$_LVL"
    _incvar "LAST$_LVL"               # increment last substate
    # STATE="$STATE.${LAST$_LVL}"
    eval "$2=\"\$$2.\$LAST$_LVL\""    # append last substate to state
}

# remove_substate() {
#     varname_or_die remove_substate "$2"
#     # LVL="$((LVL-1))"
#     #eval "$1=\"\$(($1-1))\""  # decrement LVL
#     setvar "$1" "$(($1-1))"    # decrement LVL
#     # STATE="${STATE%.*}"
#     eval "$2=\"\${$2%.*}\""    # remove number from STATE
# }

# Usage: remove_level STATE LVL
remove_level() {
    # LVL="$((LVL-1))"
    #eval "$1=\"\$(($1-1))\""  # decrement LVL
    setvar "$1" "$(($1-1))"    # decrement LVL
    # STATE="${STATE%.*}"
    varname_or_die remove_level "$2"
    eval "$2=\"\${$2%.*}\""    # remove number from STATE
}

output_rule() {
    local STATE="$2" _RULE
    getvar _RULE "$1"
    [ "$_RULE" ] && printf "%s -> %s\n" "$_RULE" "$STATE"
    unset "$1"
}

# Usage: push_state LVL STATEVAR
#
# Increment LVL by one, and add another substate onto STATEVAR. STATEVAR has
# the syntax STATE[_SUBSTATE[_SUBSUBSTATE]], with '_' as separator between
# states. STATE is guaranteed to be unique.
#
#### Goes one level deeper into hierarchy, by adding one to LEVELVAR and appending
#### a '.SUBSTATE' number to STATEVAR. SUBSTATE is guaranteed to be unique for
#### each LEVEL. (Uses forever incrementing variables ${LAST$LVL} to keep track of
#### which substates to use.)
push_state() {
    varname_or_die push_state "$1" "$2"                                    ## from add_substate
    local _LVL                                                             ## from add_substate
    _incvar "$1"                      # increment level                    ## from add_substate
    _getvar _LVL "$1"                 #   get level value                  ## from add_substate
    int_or_die push_state "$_LVL"                                          ## from add_substate
    _incvar "LAST$_LVL"               # increment last substate            ## from add_substate
    # STATE="$STATE.${LAST$_LVL}"                                          ## from add_substate
    #eval "$2=\"\$$2.\$LAST$_LVL\""    # append last substate to state      ## from add_substate
    # STATE="${STATE}_${LAST$_LVL}"
    eval "$2=\"\${$2}_\${LAST$_LVL}\""  # append last substate to state
    # varname_or_die push_state "$@"
    # local _LVL
    # _incvar "$1"                      # increment level
    # _getvar _LVL "$1"                 #   get level value
    # _incvar "LAST$_LVL"               # increment last substate
    # # STATE="$STATE.${LAST$_LVL}"
    # eval "$2=\"\$${2}_\$LAST$_LVL\""    # append last substate to state
}
# Usage: pop_state LVL STATEVAR
pop_state() {
    varname_or_die pop_state "$@"
    _decvar "$1"                # decrement LVL
    eval "$2=\"\${$2%_*}\""     # remove number from STATE
}
# Usage: inc_state STATEVAR
inc_state() {
    varname_or_die inc_state "$1"
    # case "$STATE" in
    #     *.*) STATE="${STATE%.*}.$((${STATE##*.}+1))";;
    #     *) STATE="$((STATE+1))"
    # esac
    eval "case \"\$$1\" in
        *_*) $1=\"\${$1%_*}_\$((\${$1##*_}+1))\";;
        *) $1=\"\$(($1+1))\"
    esac"
}
# Usage: trim_right SUFFIX VARNAME
#
# Trims all trailing occurrences of SUFFIX off the string in the variable
# VARNAME. If there are multiple occurrences of SUFFIX they are all trimmed
# off. (This applies ${$VARNAME%$SUFFIX} until nothing more is trimmed off.)
trim_right() { varname_or_die trim_right "$2"; _trim_right "$@"; }
_trim_right() {
    local _
    # until _="$STR";STR="${STR%$SUFFIX}";[ "$STR" = "$_" ];do :;done
    eval "until _=\"\$$2\";$2=\"\${$2%\$1}\";[ \"\$$2\" = \"\$_\" ];do :;done"
}

# Usage: set_endstate_of_groups GROUPSVAR STATE
#
# Register STATE as endpoint for each bracket group specified in the variable
# GROUPSVAR (GROUPSVAR should contains a space separated list of bracket group
# numbers). GROUPS is unset after processing, and variables 'BEG#' (where # is
# each of the group numbers found in GROUPS) will be set to STATE.
set_endstate_of_groups() {
    local GROUP GROUPS
    getvar GROUPS "$1"
    [ "$GROUPS" ] || return
    #out --------------------------------------------------------------------------------
    for GROUP in $GROUPS; do                       # intentionally unquoted
        setvar "END$GROUP" "$STATE"
        #echo "GROUP: $GROUP";
    done
    unset "$1"
}

# Usage: preparse TOKENIZED
#
# Go through TOKENIZED and populate environment with variables needed for
# 'parse' to know the end state of each parethetic group. (FIXME: Also check
# nesting for correctness?)
preparse() {
    local LVL=0 GROUPS=0 GROUP0=0 IN=0 RULE='' STATE=0
    local OUT='' END='' UNTERMINATED_GROUPS='' GRP MAX_STATE=0 PREV=''
    _DEBUG_STATE=''      # used in testing
    _DEBUG_GROUP=''
    _DEBUG_LEVEL=''
    # LVL is the current level of nesting. GROUPS in the number of the current
    # parenthesis. In '()()' GROUPS is 1 and 2, and LVL 0 and 1. In '(())' GROUPS
    # is also 1 & 2, but LVL is 0 (outside paren), 1 (inside first paren), and
    # 2 (inside innermost paren). I.e. GROUPS never decreases, while LVL does.
    # IN is the current group we're in, so in '()()' it looks like this
    # '0(1)0(2)0', while in '(())' its '0(1(2)1)0'.

    # GROUP0...N is a pseudo-array containing group stack. It has no meaning
    # outside this loop. It contains the group number of the current
    # parenthetical group at the end.
    local GROUP0=0 # group at LVL zero is group number zero
    for A in "$@"; do
        append _DEBUG_STATE "$STATE $A"
        append _DEBUG_GROUP "$IN $A"
        append _DEBUG_LEVEL "$LVL $A"
        case "$A" in
            ']'|')') :;;
            *) set_endstate_of_groups UNTERMINATED_GROUPS "$STATE";;
        esac
        case "$A" in
            '('|'[')                           # start parenthesis or bracket
                #---------------------------------------------------------------
                incvar LVL
                #---------------------------------------------------------------
                GROUPS="$((GROUPS + 1))"
                IN="$GROUPS"

                local "GROUP$LVL" "TYPE$LVL"
                setvar "GROUP$LVL" "$GROUPS"   # loop stack of group numbers
                case "$A" in                   # loop stack of bracket types
                    '(') setvar "TYPE$LVL" ')' ;;
                    '[') setvar "TYPE$LVL" ']' ;;
                esac

                local "BEG$IN"
                setvar "BEG$IN" "$STATE"      #     remember opening state
                ;;
            ']'|')')                           # end bracket
                local TYPE; getvar TYPE "TYPE$LVL"
                [ "$A" != "$TYPE" ] && die "Unexpected '$A' in rule (group $IN): $*"

                append UNTERMINATED_GROUPS "$IN"

                unset "GROUP$LVL" "TYPE$LVL"   #   remove from group stack
                #---------------------------------------------------------------
                decvar LVL
                #---------------------------------------------------------------
                getvar IN "GROUP$LVL"          #   prev group number from stack
                ;;
            '|')                               #   pipe
                getvar STATE "BEG$IN"          #     return state to start bracket
                ;;
            *)                                 #   anything else
                #---------------------------------------------------------------
                incvar MAX_STATE
                STATE="$MAX_STATE"
                #---------------------------------------------------------------
                ;;
        esac
        PREV="$A"
        # # DEBUG: Indented parse output
        # local DEBUG_INDENT DEBUG_INDENT_NEXT
        # case "$A" in
        #     '('|'[')                           # start parenthesis or bracket
        #         DEBUG_INDENT_NEXT="    $DEBUG_INDENT" ;;
        #     ']'|')')                           # end bracket
        #         DEBUG_INDENT="${DEBUG_INDENT#    }"
        #         DEBUG_INDENT_NEXT="$DEBUG_INDENT" ;;
        #     '|')                               #   pipe
        #         DEBUG_INDENT_NEXT="$DEBUG_INDENT"
        #         DEBUG_INDENT="${DEBUG_INDENT#  }" ;;
        # esac
        # out "$DEBUG_INDENT>>$A"
        # out "  ${DEBUG_INDENT}LVL:$LVL STATE:$STATE"
        # DEBUG_INDENT="$DEBUG_INDENT_NEXT"
    done
    unset "GROUP0"  # last element of group stack
    set_endstate_of_groups UNTERMINATED_GROUPS "$STATE"
    append _DEBUG_STATE "$STATE"
    append _DEBUG_GROUP "$IN"
    append _DEBUG_LEVEL "$LVL"

    # Loop through BEG0...N, and END0...N and output together
    local NUM=1 TMP TMP2
    #echo ------------------------------------------------------------
    while getvar TMP "BEG$NUM"; [ "$TMP" ]; do
        getvar TMP2 "END$NUM"
        trim_right '_0' TMP
        trim_right '_0' TMP2
        #echo "Group $NUM: $TMP -> $TMP2"
        NUM="$((NUM+1))"
    done
    #echo ------------------------------------------------------------

    if [ "$LVL" -ne 0 ]; then
        local PAREN; getvar PAREN "TYPE$LVL"
        die "Missing '$PAREN' at end of rule: $*"
    fi
    #echo "IN GROUP: $IN"
    #local I=0
    # until [ "$I" = "$GROUPS" ]; do
    #     unset "GROUP$I"
    # done

    #out "GROUPS FOUND: $GROUPS"



    # if [ "$LVL" -gt 0 ]; then
    #     die "Too few ending parentheses!!"
    # fi
}


parse() {
    out "$*"
    local LVL=0 RULE='' STATE=0
    for A in "$@"; do
        DEBUG="$A"
        case "$A" in
            '('|'[')                           # start parenthesis or bracket
                output_rule RULE "$STATE"
                add_substate LVL STATE         #   add substate
                setvar "BEG$LVL" "$STATE"      #     remember opening state
            ;;
            ')')                               # end parenthesis
                # FIXME: STATE should end in '.x'
                output_rule RULE "${STATE%.*}.x"
                unset "BEG$LVL"                #   forget opening state
                remove_level LVL STATE
                increment_state STATE
            ;;
            ']')                               # end bracket
                # FIXME: STATE should end in '.x'
                output_rule RULE "${STATE%.*}.x"
                unset "BEG$LVL"                #   forget opening state
                remove_level LVL STATE
            ;;
            '|')                               #   pipe
                # FIXME: STATE should end in '.x'
                output_rule RULE "${STATE%.*}.x"
                getvar STATE "BEG$LVL"         #     return state to start bracket
            ;;
            *)                                 #   anything else
                output_rule RULE "$STATE"

                stripzeroes REDUCED "$STATE"
                #echo "REDUCED:$STATE -> $REDUCED"
                REDUCED="$STATE"
                while [ "$REDUCED" != "${REDUCED%.0}" ]; do
                    REDUCED="${REDUCED%.0}"
                done

                RULE="$REDUCED:$A"
                increment_state STATE
                #setvar "USED$LVL" "${STATE##*.}"
                # increase USED
            ;;
        esac
        local USED BEG
        getvar USED "USED$LVL"
        getvar BEG  "BEG$LVL"

        DEBUG "$DEBUG" "STATE: $STATE" "LVL: $LVL" "BEG$LVL: $BEG" "USED$LVL: $USED"
    done
    if [ "$LVL" -gt 0 ]; then
        die "Too few ending parentheses!!"
    fi
}

################################################################################
##                                                                            ##
##  Test "Framework"                                                          ##
##                                                                            ##
################################################################################

FAILED_TESTS=0
test() {
    local MSG="$1" EXPECTED="$2" GOT="$3" EXTRA="$4"
    if [ "$GOT" != "$EXPECTED" ]; then
        out "Test failed!!!"
        out "    $MSG"
        [ "$EXTRA" ] && out "    EXTRA   :  $EXTRA"
        out "    EXPECTED: >$EXPECTED<"
        out "    GOT     : >$GOT<"
        incvar FAILED_TESTS
    fi
}

tests_done() {
    if [ "$FAILED_TESTS" -gt 0 ]; then
        printf '==============================================\n'
        printf '== %-40s ==\n' 'ERRORS!!!!!!!!!!!!11111!!!'
        printf '== %-40s ==\n' "$FAILED_TESTS tests failed!"
        printf '==============================================\n'
        exit 10
    fi
}

################################################################################
# PREPARSE, note of ending for each paren. connect the BEG$LVL or similr of
# each paren to a definite end to use.


################################################################################
##                                                                            ##
##  Tests                                                                     ##
##                                                                            ##
################################################################################

# FIXME: Allowed final states!
# FIXME: Ellipsis!

############################################################
INPUT='  (   A   )'
STATE='0 ( 0 A 1 ) 1'; FINAL="1"
GROUP='0 ( 1 A 1 ) 0'
LEVEL='0 ( 1 A 1 ) 0'
preparse $INPUT                                 # intentionally unquoted
test "States"           "$STATE" "$_DEBUG_STATE" "$INPUT"
test "Subgroup numbers" "$GROUP" "$_DEBUG_GROUP" "$INPUT"
test "Bracket level"    "$LEVEL" "$_DEBUG_LEVEL" "$INPUT"

############################################################
INPUT='  (   A   )   (   B   )'
STATE='0 ( 0 A 1 ) 1 ( 1 B 2 ) 2'; FINAL="2"
GROUP='0 ( 1 A 1 ) 0 ( 2 B 2 ) 0'
LEVEL='0 ( 1 A 1 ) 0 ( 1 B 1 ) 0'
preparse $INPUT                                # intentionally unquoted
test "States"           "$STATE" "$_DEBUG_STATE" "$INPUT"
test "Subgroup numbers" "$GROUP" "$_DEBUG_GROUP" "$INPUT"
test "Bracket level"    "$LEVEL" "$_DEBUG_LEVEL" "$INPUT"

############################################################
INPUT='  (   A   (   B   )   )'
STATE='0 ( 0 A 1 ( 1 B 2 ) 2 ) 2'; FINAL="2"
GROUP='0 ( 1 A 1 ( 2 B 2 ) 1 ) 0'
LEVEL='0 ( 1 A 1 ( 2 B 2 ) 1 ) 0'
preparse $INPUT                                # intentionally unquoted
test "States"           "$STATE" "$_DEBUG_STATE" "$INPUT"
test "Subgroup numbers" "$GROUP" "$_DEBUG_GROUP" "$INPUT"
test "Bracket level"    "$LEVEL" "$_DEBUG_LEVEL" "$INPUT"

############################################################
INPUT='  (   (   A   B   )   )'
STATE='0 ( 0 ( 0 A 1 B 2 ) 2 ) 2'; FINAL="2"
GROUP='0 ( 1 ( 2 A 2 B 2 ) 1 ) 0'
LEVEL='0 ( 1 ( 2 A 2 B 2 ) 1 ) 0'
preparse $INPUT                                # intentionally unquoted
test "States"           "$STATE" "$_DEBUG_STATE" "$INPUT"
test "Subgroup numbers" "$GROUP" "$_DEBUG_GROUP" "$INPUT"
test "Bracket level"    "$LEVEL" "$_DEBUG_LEVEL" "$INPUT"

############################################################
INPUT='  (   (   A   )   B   )'
STATE='0 ( 0 ( 0 A 1 ) 1 B 2 ) 2'; FINAL="2"
GROUP='0 ( 1 ( 2 A 2 ) 1 B 1 ) 0'
LEVEL='0 ( 1 ( 2 A 2 ) 1 B 1 ) 0'
preparse $INPUT                                # intentionally unquoted
test "States"           "$STATE" "$_DEBUG_STATE" "$INPUT"
test "Subgroup numbers" "$GROUP" "$_DEBUG_GROUP" "$INPUT"
test "Bracket level"    "$LEVEL" "$_DEBUG_LEVEL" "$INPUT"

############################################################
INPUT='  [   A   ]'
STATE='0 [ 0 A 1 ] 1'; FINAL="0 1"
GROUP='0 [ 1 A 1 ] 0'
LEVEL='0 [ 1 A 1 ] 0'
preparse $INPUT                                # intentionally unquoted
test "States"           "$STATE" "$_DEBUG_STATE" "$INPUT"
test "Subgroup numbers" "$GROUP" "$_DEBUG_GROUP" "$INPUT"
test "Bracket level"    "$LEVEL" "$_DEBUG_LEVEL" "$INPUT"

############################################################
# FIXME!! End values of paren alternatives!
INPUT='  (   A   |   B   )'
STATE='0 ( 0 A 1 | 0 B 1 ) 1'; FINAL=1
GROUP='0 ( 1 A 1 | 1 B 1 ) 0'
LEVEL='0 ( 1 A 1 | 1 B 1 ) 0'
preparse $INPUT   # intentionally unquoted
test "States"           "$STATE" "$_DEBUG_STATE" "$INPUT"
test "Subgroup numbers" "$GROUP" "$_DEBUG_GROUP" "$INPUT"
test "Bracket level"    "$LEVEL" "$_DEBUG_LEVEL" "$INPUT"


tests_done
exit


    ARGS='  [ NAME ]'
EXPECTED='0 [ 0 NAME 0 ] 0'
out $ARGS        # intentionally unquoted
preparse $ARGS   # intentionally unquoted

    ARGS='  (   (   A   (   B   |   C   [   D   ]   )   )   |   (   E   )   (   F   )   )'
EXPECTED='0 ( 0 ( 0 A 1 ( 1 B 2 | 1 C 3 [ 3 D 3 ] 3 ) 3 ) 3 | 0 ( 0 E 4 ) 4 ( 4 F 5 ) 5 ) 5'
#         0 ( 0 ( 0   1 ( 1   2 | 1   3 [ 3   3 ] 3 ) 3 ) 3 | 0 ( 0   4 ) 4 ( 4   5 ) 5 ) 5
# LEVEL:    1   2   2   3   3   3   3   4   4   4   3   2   1   2   2   2   2   2   2   1
# START:    0   0       1               3                       2       2   2       2   1

# before '|' = set group endstate
#   if type bracket = endstate = startstate
#   if type paren   = endstate = next state


out $ARGS        # intentionally unquoted
preparse $ARGS   # intentionally unquoted

echo ">$BEG2<"

exit

__END__
################################################################################
################################################################################
################################################################################
################################################################################
################################################################################


#           1.0      1.1      1.2           1.2.1
X='0 fire 1 ( bullet | torpedo ( traditional | smart ) ) 2 ( target NAME | randomly ) 3'
X='  fire   ( bullet | torpedo ( traditional | smart ) )   ( target NAME | randomly ) 3'

cat <<EXPECTED
$X
0:fire -> 1
1:bullet -> 2
1:torpedo -> 1.1
1.1:traditional -> 1.

EXPECTED


exit
:<<'BLOCK_COMMENT'

#parse thingy '(' ')' '(' ')' '(' ')' '(' ')'

parse thingy '[' tool '|' lamp ']' '(' on '|' off ')' '(' green '|' blue ')'

echo --------------------------------------------------------------------------------
X="( lamp | machine ) ( on | off | dim VALUE )"

cat <<EOF
EXPECTED
$X
0:lamp -> 1
0:machine -> 1
1:on -> 2
1:off -> 2
1:dim -> 1.1
1.1:* -> 2
EOF

parse $X

echo --------------------------------------------------------------------------------
X="0 ( 0.0 a 0.1 (0.1.0 b 0.1.1 (0.1.1.0 c 0.1.1.1 )  ) ) 1"
X="( a ( b ( c ) ) )"
cat <<EOF
EXPECTED
$X
0:a -> 0.1
0.1:b -> 0.1.0
1.1:c -> 1
EOF

parse $X

BLOCK_COMMENT

echo --------------------------------------------------------------------------------
LINE='my_program go ( --up | --down | --left | --right )'

cat <<EXPECTED
$LINE
0:go -> 1
1:--up -> 2
1:--down -> 2
1:--left -> 2
1:--right -> 2
DONE=2
--------------------
EXPECTED
LINE="${LINE#* }"
parse $LINE

#[eof]

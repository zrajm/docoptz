#!/bin/sh

# while I="$(( I + 1 ))"; [ "$I" -le "$#" ]; do
#     eval "A=\"\$$I\"; NEXT=\"\$$(( I + 1 ))\""
#     echo "$A $NEXT"

# done
# exit

# X=1
# for NEXT in "$@" ''; do
#     if [ ! "$X" ]; then
#     echo ">>>$A"

#     fi
#     A="$NEXT"
# done

# exit


#DEBUG=1
if [ "$DEBUG" ]; then
    DEBUG() { {
        printf '%s\n' "$1"; shift
        printf '    %s\n' "$@"
    } >&2; }
else
    DEBUG() { :; }
fi

################################################################################

out() { printf '%s\n' "$*"; }
die() { warn "$@"; exit 5; }
warn() { printf '%s: %s\n' "${0##*/}" "$*" >&2; :; } # always return true
varname_or_die() {
    H="${1:+$1: }"; shift
    for V in "$@"; do
        case "$V" in *[!A-Z0-9_]*|[0-9]*) die "${H}Bad variable name '$V'"; esac
    done
}
int_or_die() {
    H="${1:+$1: }"; shift
    for V in "$@"; do
        case "$V" in *[!0-9]*) die "${H}Bad integer '$V'"; esac
    done
}
# Usage: getvar VARNAME1 VARNAME2
#
# Variable VARNAME1 is set to whatever variable VARNAME2 contains.
getvar() { varname_or_die getvar "$1" "$2"; _getvar "$@"; }
_getvar() { eval "$1=\"\$$2\""; }

# Usage: getvar VARNAME1 VARNAME2
#
# Variable VARNAME1 is set to whatever variable VARNAME2 contains.
getint() { varname_or_die getint "$1" "$2"; _getint "$@"; }
_getint() {
    eval "$1=\"\$$2\"";
    int_or_die getint "$1";
}

# Usage: append VARNAME STRING
#
# Append STRING to VARNAME with a space inbetween (unless VARNAME is empty, in
# which case no space is inserted in front of STRING).
append() {
    varname_or_die append "$1";
    # VARNAME="${VARNAME:+$VARNAME }$2"
    eval "$1=\"\${$1:+\$$1 }\$2\""
}

# Usage: setvar VARNAME VALUE
#
# Set variable VARNAME to the specified value.
setvar() { varname_or_die setvar "$1"; _setvar "$@"; }
_setvar() { eval "$1=\"\$2\""; }

# Usage: incvar VARNAME
#
# Sets variable VARNAME to 0 if unset, otherwise increment VARNAME by one.
incvar() { varname_or_die incvar "$1"; _incvar "$@"; }
_incvar() { eval "$1=\"\$((\${$1:--1} + 1))\""; } #VAR="$((${VAR:--1} + 1))"

# Usage: decvar VARNAME
#
# Sets variable VARNAME to 0 if unset, otherwise decrement VARNAME by one.
decvar() { varname_or_die decvar "$1"; _decvar "$@"; }
_decvar() { _setvar "$1" "$(($1 - 1))"; }

# Usage: VARNAME VALUE
#
# Set varible VARNAME to VALUE, except remove all trailing '.0' first.
stripzeroes() {
    #R="$STATE"
    #while [ "$R" != "${R%.0}" ]; do R="${R%.0}"; done
    eval "$1=\"\$2\";
    while [ \"\$$1\" != \"\${$1%.0}\" ]; do $1=\"\${$1%.0}\"; done"
}

# Usage: increment_state STATE
#
# Where STATE is a number like '0' or '1.2' or '0.2.3'. Increments last digit
# of state by one.
increment_state() {
    # case "$STATE" in
    #     *.*) STATE="${STATE%.*}.$((${STATE##*.}+1))";;
    #     *) STATE="$((STATE+1))"
    # esac
    varname_or_die increment_state "$1"
    eval "case \"\$$1\" in
        *.*) $1=\"\${$1%.*}.\$((\${$1##*.}+1))\";;
        *) $1=\"\$(($1+1))\"
    esac"
}

# Usage: LEVELVAR STATEVAR
#
# Goes one level deeper into hierarchy, by adding one to LEVELVAR and appending
# a '.SUBSTATE' number to STATEVAR. SUBSTATE is guaranteed to be unique for
# each LEVEL. (Uses forever incrementing variables ${LAST$LVL} to keep track of
# which substates to use.)
add_substate() {
    varname_or_die add_substate "$1" "$2"
    local _LVL
    _incvar "$1"                      # increment level
    _getvar _LVL "$1"                 #   get level value
    int_or_die add_substate "$_LVL"
    _incvar "LAST$_LVL"               # increment last substate
    # STATE="$STATE.${LAST$_LVL}"
    eval "$2=\"\$$2.\$LAST$_LVL\""    # append last substate to state
}

# remove_substate() {
#     varname_or_die remove_substate "$2"
#     # LVL="$((LVL-1))"
#     #eval "$1=\"\$(($1-1))\""  # decrement LVL
#     setvar "$1" "$(($1-1))"    # decrement LVL
#     # STATE="${STATE%.*}"
#     eval "$2=\"\${$2%.*}\""    # remove number from STATE
# }

# Usage: remove_level STATE LVL
remove_level() {
    # LVL="$((LVL-1))"
    #eval "$1=\"\$(($1-1))\""  # decrement LVL
    setvar "$1" "$(($1-1))"    # decrement LVL
    # STATE="${STATE%.*}"
    varname_or_die remove_level "$2"
    eval "$2=\"\${$2%.*}\""    # remove number from STATE
}

output_rule() {
    local STATE="$2" _RULE
    getvar _RULE "$1"
    [ "$_RULE" ] && printf "%s -> %s\n" "$_RULE" "$STATE"
    unset "$1"
}

# Usage: push_state LVL STATEVAR
#
# Increment LVL by one, and add another substate onto STATEVAR. STATEVAR has
# the syntax STATE[_SUBSTATE[_SUBSUBSTATE]], with '_' as separator between
# states. STATE is guaranteed to be unique.
#
#### Goes one level deeper into hierarchy, by adding one to LEVELVAR and appending
#### a '.SUBSTATE' number to STATEVAR. SUBSTATE is guaranteed to be unique for
#### each LEVEL. (Uses forever incrementing variables ${LAST$LVL} to keep track of
#### which substates to use.)
push_state() {
    varname_or_die push_state "$1" "$2"                                    ## from add_substate
    local _LVL                                                             ## from add_substate
    _incvar "$1"                      # increment level                    ## from add_substate
    _getvar _LVL "$1"                 #   get level value                  ## from add_substate
    int_or_die push_state "$_LVL"                                          ## from add_substate
    _incvar "LAST$_LVL"               # increment last substate            ## from add_substate
    # STATE="$STATE.${LAST$_LVL}"                                          ## from add_substate
    #eval "$2=\"\$$2.\$LAST$_LVL\""    # append last substate to state      ## from add_substate
    # STATE="${STATE}_${LAST$_LVL}"
    eval "$2=\"\${$2}_\${LAST$_LVL}\""  # append last substate to state
    # varname_or_die push_state "$@"
    # local _LVL
    # _incvar "$1"                      # increment level
    # _getvar _LVL "$1"                 #   get level value
    # _incvar "LAST$_LVL"               # increment last substate
    # # STATE="$STATE.${LAST$_LVL}"
    # eval "$2=\"\$${2}_\$LAST$_LVL\""    # append last substate to state
}
# Usage: pop_state LVL STATEVAR
pop_state() {
    varname_or_die pop_state "$@"
    _decvar "$1"                # decrement LVL
    eval "$2=\"\${$2%_*}\""     # remove number from STATE
}
# Usage: inc_state STATEVAR
inc_state() {
    varname_or_die inc_state "$1"
    # case "$STATE" in
    #     *.*) STATE="${STATE%.*}.$((${STATE##*.}+1))";;
    #     *) STATE="$((STATE+1))"
    # esac
    eval "case \"\$$1\" in
        *_*) $1=\"\${$1%_*}_\$((\${$1##*_}+1))\";;
        *) $1=\"\$(($1+1))\"
    esac"
}
# Usage: trim_right SUFFIX VARNAME
#
# Trims all trailing occurrences of SUFFIX off the string in the variable
# VARNAME. If there are multiple occurrences of SUFFIX they are all trimmed
# off. (This applies ${$VARNAME%$SUFFIX} until nothing more is trimmed off.)
trim_right() { varname_or_die trim_right "$2"; _trim_right "$@"; }
_trim_right() {
    local _
    # until _="$STR";STR="${STR%$SUFFIX}";[ "$STR" = "$_" ];do :;done
    eval "until _=\"\$$2\";$2=\"\${$2%\$1}\";[ \"\$$2\" = \"\$_\" ];do :;done"
}

# Usage: preparse TOKENIZED
#
# Go through TOKENIZED and populate environment with variables needed for
# 'parse' to know the end state of each parethetic group. (FIXME: Also check
# nesting for correctness?)


# Special characters
# ==================
#   * Group start is '[' or '('
#   * Group end is ']' or ')'
#   * Subgroup separator is '|'
#   * Repeat is '...'
#
# The beginning of a subgroup can be attached to one or more states (if the
# previous subgroup[s] where optional). The first part of each subgroup is
# therefore connected to all the STARTAT states (space-separated list state
# identifiers). The remaining group states should be the same regardless of
# which 'entry' was taken.
#

# LVL=0 LASTSTATE=0 STARTAT=0
#
# Processing '[' and '(' (the same):
#   incvar LVL LASTSTATE
#   for BEGSTATE in $STARTAT; do
#       add rule "BEGSTATE:$ARG -> $LASTSTATE"
#   done
#
# Processing ']' and ')' (almost the same):
#   decval LVL
#   if ']':
#       add rule '
#
# Processing '|':
# Processing '...':
#

# LVL is the current level of nesting. GROUPS in the number of the current
# parenthesis. In '()()' GROUPS is 1 and 2, and LVL 0 and 1. In '(())' GROUPS
# is also 1 & 2, but LVL is 0 (outside paren), 1 (inside first paren), and 2
# (inside innermost paren). I.e. GROUPS never decreases, while LVL does. IN is
# the current group we're in, so in '()()' it looks like this '0(1)0(2)0',
# while in '(())' its '0(1(2)1)0'.

#
# GROUP0...N is a pseudo-array containing group stack. It has no meaning
# outside this loop. It contains the group number of the current parenthetical
# group at the end.
#
# TYPE0...N is pseudo-array containing group type. TYPE0='' (because its not
# within brackets), all higher numbers are either ']' or ')' depending on
# whether it's a [...] or (...) group.
preparse() {
    local RULE=0                               # rule 'array' length
    local STARTAT=0                            # startat 'array' length
    local STATE=0 STATECOUNT=0
    local TYPE=''
    local OUT='' END=''
    _DEBUG_STATE=''      # used in testing
    _DEBUG_GROUP=''
    _DEBUG_LEVEL=''
    local LVL=0 GROUPS=0 IN=0 GROUP0=0 TYPE0=''

    # Loop over $@ while setting $A to current arg, and $NEXT to next arg.
    local I=0 A='' NEXT=''
    while I="$(( I + 1 ))"; [ "$I" -le "$#" ]; do
        eval    A="\"\$$I\""                   # current arg
        eval NEXT="\"\$$(( I + 1 ))\""         #   next arg
        append _DEBUG_STATE "$STATE $A"
        append _DEBUG_GROUP "$IN $A"
        append _DEBUG_LEVEL "$LVL $A"
        case "$A" in
            ['(['])                           # start parenthesis or bracket
                _incvar LVL                    #   group level
                _incvar GROUPS                 #   group number
                IN="$GROUPS"                   #   current group number
                local "GROUP$LVL"="$GROUPS"    #   loop stack: group number stack
                case "$A" in                   #   loop stack: group types
                    '(') local "TYPE$LVL"=')' ;;
                    '[') local "TYPE$LVL"=']' ;;
                esac
                local "BEG$IN"="$STATE"        #   array: group start state
                _incvar STATECOUNT
                local "END$IN"="$STATECOUNT"   #   array: group end state
                ;;
            ['])'])                           # end bracket
                _getvar TYPE "TYPE$LVL"
                [ "$LVL" -le 0    ] && warn "Too many '$A' in rule: $*" && return 1
                [ "$A" != "$TYPE" ] && warn "Missing '$A' in rule (group $IN): $*" && return 1

                #getvar STATE "END$IN"          #     return state to start bracket

                unset "GROUP$LVL" "TYPE$LVL"   #   remove from group stack
                _decvar LVL                    #   go down one level
                _getvar IN "GROUP$LVL"         #   current group number
                case "$NEXT" in [')]'])
                    local "END$IN"="$STATE"
                esac

                ;;
            '|')                               #   pipe
                _getvar STATE "BEG$IN"         #     return state to start bracket
                ;;
            '...')
                ;;
            *)                                 #   anything else
                case "$NEXT" in
                    ['|)]'])
                        _getvar STATE "END$IN"
                        ;;
                    *)
                        _incvar STATECOUNT
                        STATE="$STATECOUNT"
                        ;;
                esac
                ;;
        esac
        # # DEBUG: Indented parse output
        # local DEBUG_INDENT DEBUG_INDENT_NEXT
        # case "$A" in
        #     '('|'[')                           # start parenthesis or bracket
        #         DEBUG_INDENT_NEXT="    $DEBUG_INDENT" ;;
        #     ']'|')')                           # end bracket
        #         DEBUG_INDENT="${DEBUG_INDENT#    }"
        #         DEBUG_INDENT_NEXT="$DEBUG_INDENT" ;;
        #     '|')                               #   pipe
        #         DEBUG_INDENT_NEXT="$DEBUG_INDENT"
        #         DEBUG_INDENT="${DEBUG_INDENT#  }" ;;
        # esac
        # out "$DEBUG_INDENT>>$A"
        # out "  ${DEBUG_INDENT}LVL:$LVL STATE:$STATE"
        # DEBUG_INDENT="$DEBUG_INDENT_NEXT"
    done
    unset "GROUP0"  # last element of group stack
    unset "TYPE0"
    append _DEBUG_STATE "$STATE"
    append _DEBUG_GROUP "$IN"
    append _DEBUG_LEVEL "$LVL"

    if [ "$LVL" -ne 0 ]; then
        local PAREN; getvar PAREN "TYPE$LVL"
        warn "Missing '$PAREN' at end of rule: $*"
        return 1
    fi
}

parse() {
    out "$*"
    local LVL=0 RULE='' STATE=0
    for A in "$@"; do
        DEBUG="$A"
        case "$A" in
            '('|'[')                           # start parenthesis or bracket
                output_rule RULE "$STATE"
                add_substate LVL STATE         #   add substate
                setvar "BEG$LVL" "$STATE"      #     remember opening state
            ;;
            ')')                               # end parenthesis
                # FIXME: STATE should end in '.x'
                output_rule RULE "${STATE%.*}.x"
                unset "BEG$LVL"                #   forget opening state
                remove_level LVL STATE
                increment_state STATE
            ;;
            ']')                               # end bracket
                # FIXME: STATE should end in '.x'
                output_rule RULE "${STATE%.*}.x"
                unset "BEG$LVL"                #   forget opening state
                remove_level LVL STATE
            ;;
            '|')                               #   pipe
                # FIXME: STATE should end in '.x'
                output_rule RULE "${STATE%.*}.x"
                getvar STATE "BEG$LVL"         #     return state to start bracket
            ;;
            *)                                 #   anything else
                output_rule RULE "$STATE"

                stripzeroes REDUCED "$STATE"
                #echo "REDUCED:$STATE -> $REDUCED"
                REDUCED="$STATE"
                while [ "$REDUCED" != "${REDUCED%.0}" ]; do
                    REDUCED="${REDUCED%.0}"
                done

                RULE="$REDUCED:$A"
                increment_state STATE
                #setvar "USED$LVL" "${STATE##*.}"
                # increase USED
            ;;
        esac
        local USED BEG
        getvar USED "USED$LVL"
        getvar BEG  "BEG$LVL"

        DEBUG "$DEBUG" "STATE: $STATE" "LVL: $LVL" "BEG$LVL: $BEG" "USED$LVL: $USED"
    done
    if [ "$LVL" -gt 0 ]; then
        die "Too few ending parentheses!!"
    fi
}

################################################################################
##                                                                            ##
##  Test "Framework"                                                          ##
##                                                                            ##
################################################################################

FAILED_TESTS=0
TESTS_COUNT=0
# Arg order SHOULD BE: GOT EXPECTED [MESSAGE] 
test() {
    local MSG="$1" EXPECTED="$2" GOT="$3" EXTRA="$4"
    TESTS_COUNT="$(( TESTS_COUNT + 1 ))"
    if [ "$GOT" != "$EXPECTED" ]; then
        out "Test failed!!!"
        out "    $MSG"
        [ "$EXTRA" ] && out "    EXTRA   :  $EXTRA"
        out "    EXPECTED: >$EXPECTED<"
        out "    GOT     : >$GOT<"
        incvar FAILED_TESTS
    fi
}

tests_done() {
    TESTS_DONE=1
    if [ "$FAILED_TESTS" -gt 0 ]; then
        printf '==============================================\n'
        printf '== %-40s ==\n' 'ERRORS!!!!!!!!!!!!11111!!!'
        printf '== %-40s ==\n' "$FAILED_TESTS tests failed!"
        printf '==============================================\n'
        exit 10
    else
        printf "All %s tests passed.\n" "$TESTS_COUNT"
    fi
}


################################################################################
##                                                                            ##
##  'Array' stuff                                                             ##
##                                                                            ##
################################################################################

## Some pseudo-array idioms for dash:
##
## Init: Create length counter (nothing more):
##
##     local NAME="0"
##
## Push: Put content into variable named NAME# (where # is the number of the
## element added) then increment length counter by one.
##
##     local "NAME$NAME"="SOMETHING"; $NAME="$(( NAME + 1))"
##
## Pop: First decrement length counter then get and unset the last element.
##
##     NAME="$(( NAME - 1 ))"; eval "VALUE=\"\$NAME$NAME\""; unset "NAME$NAME"
##
## Change value:
##
##     local "NAME$NAME"="NEW VALUE"
##
## Loop over:
##
##     local I=-1
##     while I="$(( I + 1 ))"; [ "$I" -lt "$NAME" ]; do
##         eval "VALUE=\"\$NAME$I\""
##         # do stuff here
##     done
##
## Go through and empty a stack (backwards order).
##
##     while [ "$NAME" -gt 0 ]; do
##         NAME="$(( NAME - 1 ))"; eval "VALUE=\"\$NAME$NAME\""; unset "NAME$NAME"
##         echo "NAME:$NAME"
##         echo "$VALUE"
##     done
##
## Go through and empty a stack from first to last item (array will be invalid
## during traversal but in valid state after loop is done).
##
##     local I=-1
##     while I="$(( I + 1 ))"; [ "$I" -lt "$NAME" ]; do
##         eval "VALUE=\"\$NAME$I\""; unset "NAME$I"
##         echo "NAME:$NAME"
##         echo "$VALUE"
##     done
##     NAME=0
##

ok_varname() {
    H="${1:+$1: }"; shift
    for V in "$@"; do
        case "$V" in
            *[!A-Z0-9_]*|[0-9]*)
                warn "${H}Bad variable name '$V'"
                return 1
        esac
    done
    return 0
}

ok_int() {
    H="${1:+$1: }"; shift
    for V in "$@"; do
        case "$V" in
            *[!0-9]*)
                warn "${H}Bad integer '$V'"
                return 1
        esac
    done
    return 0
}

# Usage: length ARRAY VARNAME
length() {
    ok_varname length "$@" || return 1         # verify ARRAY & VARNAME
    eval "local _=\${$1_:-0}"                  # get length
    ok_int length "$_" || return 1             # verify length
    eval "$2=\"\$_\""
    return 0
}

# Usage: get ARRAY INDEX VARNAME
#
# Set variable VARNAME to element INDEX of ARRAY.
get() {
    ok_varname get "$1" "$3" || return 1       # verify ARRAY & VARNAME
    ok_int     get "$2"      || return 1       # verify INDEX
    eval "local _=\${$1_:-0}"                  # get length
    ok_int 'get (array length)' "$_" || return 1 # verify length
    [ "$2" -ge "$_" ] && warn "get: Index '$2' too large (max is '$((_ - 1))')" && return 1
    eval "$3=\"\$$1_$2\""
}

# Usage: push ARRAY VALUE
#
# Pushes VALUE onto pseudo-array 'ARRAY'. If called inside a function you
# should also invoke `local "ARRAY$ARRAY"`, before calling this.
push() {
    ok_varname push "$1" || return 1           # verify ARRAY
    eval "local _=\${$1_:-0}"                  # get length
    ok_int push "$_" || return 1               # verify length
    eval "${1}_$_=\"\$2\""                     # set array element
    eval "${1}_=$(( $_ + 1 ))"                 # increase length
    return 0
}

# Usage: pop ARRAY VARNAME
pop() {
    ok_varname pop "$@" || return 1            # verify ARRAY & VARNAME
    eval "local _=\${$1_:-0}"                  # get length
    ok_int pop "$_" || return 1                # verify length
    if [ "$_" -le 0 ]; then
        warn "pop: Array '$1' is empty"
        return 1
    fi
    eval "_=$(( _ - 1 ))"                      # length - 1
    eval "${1}_=\"\$_\""                       # decrease length
    eval "$2=\"\$${1}_$_\""                    # get array element
    unset "${1}_$_"                            # unset last element
    return 0
}

## # Usage: push ARRAY VALUE
## #
## # Pushes VALUE onto pseudo-array 'ARRAY'. If called inside a function you
## # should also invoke `local "ARRAY$ARRAY"`, before calling this.
## push() {
##     varname_or_die push "$1"
##     eval "_=\$$1"; int_or_die push "$_"
##     eval "$1$_=\"\$2\"; $1=$(( $1 + 1 ))"
## }
##
## # Usage: get ARRAY VARNAME
## #
## # Pops last value of off ARRAY and puts it into variable named VARNAME.
## pop() {
##     varname_or_die pop "$@"
##     eval "local _=\$$1"; int_or_die pop "$_"  # get array length
##     if [ "$_" -gt 0 ]; then
##         warn "pop: Array is empty"
##         return 1
##     fi
##     _="$(( _ - 1 ))"                          # length -1
##     eval "$2=\"\$$1$_\""                      # set VARNAME
##     unset "$1$_"                              # unset last array element
##     eval "$1=\"\$_\""                         # decrement array counter
## }
##
## # Usage: get ARRAY INDEX VARNAME
## #
## # Set variable VARNAME to element INDEX of ARRAY.
## get() {
##     varname_or_die pop "$1" "$3"
##     eval "local _=\$$1"; int_or_die pop "$_"
##     if [ "$2" -ge "$_" ]; then
##         die "get: Index '$_' must be less than array length '$_'"
##         return 1
##     fi
##     eval "$3=\"\$$1$2\""
## }

################################################################################



################################################################################
# PREPARSE, note of ending for each paren. connect the BEG$LVL or similr of
# each paren to a definite end to use.


################################################################################
##                                                                            ##
##  Tests                                                                     ##
##                                                                            ##
################################################################################

# FIXME: Allowed final states!
# FIXME: Ellipsis!

############################################################
TESTS_DONE=''
TMPDIR="$(mktemp -dt zdocpt2-XXXXXX)"
TMPNUM="0"
BIN="${0##*/}"
trap "trap - EXIT INT
     [ -d '$TMPDIR' ] && rm -r '$TMPDIR';
     [ \"\$TESTS_DONE\" ] || out '***PREMATURE EXIT! Not all tests ran!';
     exit" EXIT INT

# Usage: inctmp VARNAME
#
# Sets variable VARNAME to next suitable tempfile.
inctmp() { setvar "$1" "$TMPDIR/$TMPNUM"; incvar TMPNUM; }

######################################################################
##
##  Test get()
##

# get: Bad 1st arg, ARRAY is a number instead of ARRAY name
inctmp TMPFILE
ARRAY="original"
get 666 0 ARRAY 2>"$TMPFILE"; RETVAL="$?"
read ERRMSG <"$TMPFILE"
test 'Return value'       "1"                                  "$RETVAL"
test 'Error message'      "$BIN: get: Bad variable name '666'" "$ERRMSG"
test 'Variable unchanged' "$ARRAY"                             "original"

# get: Bad 1st arg, ARRAY with malformed length
inctmp TMPFILE
ARRAY_=-1                                      # malformed 'array' (bad length)
VARNAME=42
get ARRAY 3 VARNAME 2>"$TMPFILE"; RETVAL="$?"
read ERRMSG <"$TMPFILE"
test 'Return value'       "1"                           "$RETVAL"
test 'Error message'      "$BIN: get (array length): Bad integer '-1'" "$ERRMSG"
test 'Variable unchanged' "$VARNAME"                    "42"

# get: Bad 2nd arg, INDEX is invalid integer
inctmp TMPFILE
ARRAY="original"          # (a non-array)
VARNAME=42
get ARRAY -1 VARNAME 2>"$TMPFILE"; RETVAL="$?"
read ERRMSG <"$TMPFILE"
test 'Return value'       "1"                           "$RETVAL"
test 'Error message'      "$BIN: get: Bad integer '-1'" "$ERRMSG"
test 'Variable unchanged' "$ARRAY"                      "original"
test 'Variable unchanged' "$VARNAME"                    "42"

# get: Bad 2nd arg, INDEX out of range
inctmp TMPFILE
ARRAY_=3; ARRAY_0="a"; ARRAY_1="b"; ARRAY_2="c"            # a real 'array'
VARNAME=42
get ARRAY 3 VARNAME 2>"$TMPFILE"; RETVAL="$?"
read ERRMSG <"$TMPFILE"
test 'Return value'       "1"                           "$RETVAL"
test 'Error message'      "$BIN: get: Index '3' too large (max is '2')" "$ERRMSG"
test 'Variable unchanged' "$VARNAME"                    "42"

# get: Bad 3rd arg, VARNAME is a number instead of variable name
inctmp TMPFILE
ARRAY="original"          # (a non-array)
VARNAME=42
get ARRAY 0 666 2>"$TMPFILE"; RETVAL="$?"
read ERRMSG <"$TMPFILE"
test 'Return value'       "1"                           "$RETVAL"
test 'Error message'      "$BIN: get: Bad variable name '666'" "$ERRMSG"
test 'Variable unchanged' "$ARRAY"                      "original"
test 'Variable unchanged' "$VARNAME"                    "42"

# get: Good args
inctmp TMPFILE
ARRAY_=3; ARRAY_0="a"; ARRAY_1="b"; ARRAY_2="c"            # a real 'array'
VARNAME=42
get ARRAY 2 VARNAME 2>"$TMPFILE"; RETVAL="$?"
read ERRMSG <"$TMPFILE"
test 'Return value'       "0"                           "$RETVAL"
test 'Variable changed'   "$VARNAME"                    "c"

######################################################################
##
##  Test push(), get(), length() and pop()
##  FIXME: Break these apart and test them more thoroughly

ORG_="$_"
push X a
length X LEN
test 'Length'        '1'     "$LEN"
test '$X_ (length)'  '1'     "$X_"
test '$X_0'          'a'     "$X_0"
test '$X_1'          ''      "$X_1"
test 'leaking $_?'   "$ORG_" "$_"

push X b
length X LEN
test 'Length'        '2'     "$LEN"
test '$X_ (length)'  '2'     "$X_"
test '$X_0'          'a'     "$X_0"
test '$X_1'          'b'     "$X_1"
test '$X_2'          ''      "$X_2"
test 'leaking $_?'   "$ORG_" "$_"

get X 0 VAL
length X LEN
test 'Length'        '2'     "$LEN"
test '$X_ (length)'  '2'     "$X_"
test '$X_0'          'a'     "$X_0"
test '$X_1'          'b'     "$X_1"
test '$X_2'          ''      "$X_2"
test 'leaking $_?'   "$ORG_" "$_"

pop X VALUE
length X LEN
test 'Gotted value'  'b'     "$VALUE"
test 'Length'        '1'     "$LEN"
test '$X_ (length)'  '1'     "$X_"
test '$X_0'          'a'     "$X_0"
test '$X_1'          ''      "$X_1"
test 'leaking $_?'   "$ORG_" "$_"

pop X VALUE
length X LEN
test 'Gotted value'  'a'     "$VALUE"
test 'Length'        '0'     "$LEN"
test '$X_ (length)'  '0'     "$X_"
test '$X_0'          ''      "$X_0"
test '$X_1'          ''      "$X_1"
test 'leaking $_?'   "$ORG_" "$_"

inctmp TMPFILE
pop X VALUE 2>"$TMPFILE"; RETVAL="$?"      # intentionally unquoted
read ERRMSG <"$TMPFILE"
test 'Return value'  "1" "$RETVAL"
test 'Error message' "$BIN: pop: Array 'X' is empty" "$ERRMSG"

######################################################################
##
##  Test preparse() error messages
##

## One ')' too many
INPUT='A )'
inctmp TMPFILE
preparse $INPUT 2>"$TMPFILE"; RETVAL="$?"      # intentionally unquoted
read ERRMSG <"$TMPFILE"
test 'Return value'  "1" "$RETVAL"
test 'Error message' "$BIN: Too many ')' in rule: A )" "$ERRMSG"

## One ']' too many
INPUT='A ]'
inctmp TMPFILE
preparse $INPUT 2>"$TMPFILE"; RETVAL="$?"      # intentionally unquoted
read ERRMSG <"$TMPFILE"
test 'Return value'  "1" "$RETVAL"
test 'Error message' "$BIN: Too many ']' in rule: A ]" "$ERRMSG"

## Missing ')'
INPUT='[ A )'
inctmp TMPFILE
preparse $INPUT 2>"$TMPFILE"; RETVAL="$?"      # intentionally unquoted
read ERRMSG <"$TMPFILE"
test 'Return value'  "1" "$RETVAL"
test 'Error message' "$BIN: Missing ')' in rule (group 1): [ A )" "$ERRMSG"

## Missing ']'
INPUT='( A ]'
inctmp TMPFILE
preparse $INPUT 2>"$TMPFILE"; RETVAL="$?"
read ERRMSG <"$TMPFILE"
test 'Return value'  "1" "$RETVAL"
test 'Error message' "$BIN: Missing ']' in rule (group 1): ( A ]" "$ERRMSG"

## Missing ']'
INPUT='( A'
inctmp TMPFILE
preparse $INPUT 2>"$TMPFILE"; RETVAL="$?"
read ERRMSG <"$TMPFILE"
test 'Return value'  "1" "$RETVAL"
test 'Error message' "$BIN: Missing ')' at end of rule: ( A" "$ERRMSG"

######################################################################
##
##  Test Actual Results
##

INPUT='  A'
LEVEL='0 A 0'
GROUP='0 A 0'
STATE='0 A 1'; FINAL='1'
preparse $INPUT; RETVAL="$?"                   # intentionally unquoted
test 'Return value'     "0"      "$RETVAL"
test 'Bracket level'    "$LEVEL" "$_DEBUG_LEVEL" "$INPUT"
test 'Group numbers'    "$GROUP" "$_DEBUG_GROUP" "$INPUT"
test 'State numbers'    "$STATE" "$_DEBUG_STATE" "$INPUT"

INPUT='  A   B'
LEVEL='0 A 0 B 0'
GROUP='0 A 0 B 0'
STATE='0 A 1 B 2'; FINAL='2'
preparse $INPUT; RETVAL="$?"                   # intentionally unquoted
test 'Return value'     "0"      "$RETVAL"
test 'Bracket level'    "$LEVEL" "$_DEBUG_LEVEL" "$INPUT"
test 'Group numbers'    "$GROUP" "$_DEBUG_GROUP" "$INPUT"
test 'State numbers'    "$STATE" "$_DEBUG_STATE" "$INPUT"

INPUT='  (   A   )   B'
LEVEL='0 ( 1 A 1 ) 0 B 0'
GROUP='0 ( 1 A 1 ) 0 B 0'
STATE='0 ( 0 A 1 ) 1 B 2'; FINAL='2'
preparse $INPUT; RETVAL="$?"                   # intentionally unquoted
test 'Return value'     "0"      "$RETVAL"
test 'Bracket level'    "$LEVEL" "$_DEBUG_LEVEL" "$INPUT"
test 'Group numbers'    "$GROUP" "$_DEBUG_GROUP" "$INPUT"
test 'State numbers'    "$STATE" "$_DEBUG_STATE" "$INPUT"

INPUT='  (   A   )   (   B   )'
LEVEL='0 ( 1 A 1 ) 0 ( 1 B 1 ) 0'
GROUP='0 ( 1 A 1 ) 0 ( 2 B 2 ) 0'
STATE='0 ( 0 A 1 ) 1 ( 1 B 2 ) 2'; FINAL='2'
preparse $INPUT; RETVAL="$?"                   # intentionally unquoted
test 'Return value'     "0"      "$RETVAL"
test 'Bracket level'    "$LEVEL" "$_DEBUG_LEVEL" "$INPUT"
test 'Group numbers'    "$GROUP" "$_DEBUG_GROUP" "$INPUT"
test 'State numbers'    "$STATE" "$_DEBUG_STATE" "$INPUT"

INPUT='  (   (   A   )   B   )'
LEVEL='0 ( 1 ( 2 A 2 ) 1 B 1 ) 0'
GROUP='0 ( 1 ( 2 A 2 ) 1 B 1 ) 0'
STATE='0 ( 0 ( 0 A 2 ) 2 B 1 ) 1'; FINAL='1'
preparse $INPUT; RETVAL="$?"                   # intentionally unquoted
test 'Return value'     "0"      "$RETVAL"
test 'Bracket level'    "$LEVEL" "$_DEBUG_LEVEL" "$INPUT"
test 'Group numbers'    "$GROUP" "$_DEBUG_GROUP" "$INPUT"
test 'State numbers'    "$STATE" "$_DEBUG_STATE" "$INPUT"

INPUT='  (   A   (   B   )   )'
LEVEL='0 ( 1 A 1 ( 2 B 2 ) 1 ) 0'
GROUP='0 ( 1 A 1 ( 2 B 2 ) 1 ) 0'
STATE='0 ( 0 A 2 ( 2 B 3 ) 3 ) 3'; FINAL='3' # (state 1 never used)
preparse $INPUT; RETVAL="$?"                   # intentionally unquoted
test 'Return value'     "0"      "$RETVAL"
test 'Bracket level'    "$LEVEL" "$_DEBUG_LEVEL" "$INPUT"
test 'Group numbers'    "$GROUP" "$_DEBUG_GROUP" "$INPUT"
test 'State numbers'    "$STATE" "$_DEBUG_STATE" "$INPUT"

INPUT='  (   A   (   B   (   C   )   )   )'
LEVEL='0 ( 1 A 1 ( 2 B 2 ( 3 C 3 ) 2 ) 1 ) 0'
GROUP='0 ( 1 A 1 ( 2 B 2 ( 3 C 3 ) 2 ) 1 ) 0'
STATE='0 ( 0 A 2 ( 2 B 4 ( 4 C 5 ) 5 ) 5 ) 5'; FINAL='3' # (state 1 & 3 never used)
preparse $INPUT; RETVAL="$?"                   # intentionally unquoted
test 'Return value'     "0"      "$RETVAL"
test 'Bracket level'    "$LEVEL" "$_DEBUG_LEVEL" "$INPUT"
test 'Group numbers'    "$GROUP" "$_DEBUG_GROUP" "$INPUT"
test 'State numbers'    "$STATE" "$_DEBUG_STATE" "$INPUT"

INPUT='  (   A   B   C   |   D   E   F   |   G   H   I   )   X'
LEVEL='0 ( 1 A 1 B 1 C 1 | 1 D 1 E 1 F 1 | 1 G 1 H 1 I 1 ) 0 X 0'
GROUP='0 ( 1 A 1 B 1 C 1 | 1 D 1 E 1 F 1 | 1 G 1 H 1 I 1 ) 0 X 0'
STATE='0 ( 0 A 2 B 3 C 1 | 0 D 4 E 5 F 1 | 0 G 6 H 7 I 1 ) 1 X 8'
preparse $INPUT; RETVAL="$?"                   # intentionally unquoted
test 'Return value'     "0"      "$RETVAL"
test 'Bracket level'    "$LEVEL" "$_DEBUG_LEVEL" "$INPUT"
test 'Group numbers'    "$GROUP" "$_DEBUG_GROUP" "$INPUT"
test 'State numbers'    "$STATE" "$_DEBUG_STATE" "$INPUT"

INPUT='  [   A   B   C   |   D   E   F   |   G   H   I   ]   X'
LEVEL='0 [ 1 A 1 B 1 C 1 | 1 D 1 E 1 F 1 | 1 G 1 H 1 I 1 ] 0 X 0'
GROUP='0 [ 1 A 1 B 1 C 1 | 1 D 1 E 1 F 1 | 1 G 1 H 1 I 1 ] 0 X 0'
STATE='0 [ 0 A 2 B 3 C 1 | 0 D 4 E 5 F 1 | 0 G 6 H 7 I 1 ] 1 X 8'
preparse $INPUT; RETVAL="$?"                   # intentionally unquoted
test 'Return value'     "0"      "$RETVAL"
test 'Bracket level'    "$LEVEL" "$_DEBUG_LEVEL" "$INPUT"
test 'Group numbers'    "$GROUP" "$_DEBUG_GROUP" "$INPUT"
test 'State numbers'    "$STATE" "$_DEBUG_STATE" "$INPUT"

INPUT='  [   A   B   C   |   D   E   F   |   G   H   I   ]   ...  X'
LEVEL='0 [ 1 A 1 B 1 C 1 | 1 D 1 E 1 F 1 | 1 G 1 H 1 I 1 ] 0 ... 0 X 0'
GROUP='0 [ 1 A 1 B 1 C 1 | 1 D 1 E 1 F 1 | 1 G 1 H 1 I 1 ] 0 ... 0 X 0'
STATE='0 [ 0 A 2 B 3 C 1 | 0 D 4 E 5 F 1 | 0 G 6 H 7 I 1 ] 1 ... 1 X 8'
preparse $INPUT; RETVAL="$?"                   # intentionally unquoted
test 'Return value'     "0"      "$RETVAL"
test 'Bracket level'    "$LEVEL" "$_DEBUG_LEVEL" "$INPUT"
test 'Group numbers'    "$GROUP" "$_DEBUG_GROUP" "$INPUT"
test 'State numbers'    "$STATE" "$_DEBUG_STATE" "$INPUT"

INPUT='  (   A   )'
LEVEL='0 ( 1 A 1 ) 0'
GROUP='0 ( 1 A 1 ) 0'
STATE='0 ( 0 A 1 ) 1'; FINAL="1"
preparse $INPUT; RETVAL="$?"                   # intentionally unquoted
test 'Return value'     "0"      "$RETVAL"
test 'Bracket level'    "$LEVEL" "$_DEBUG_LEVEL" "$INPUT"
test 'Group numbers'    "$GROUP" "$_DEBUG_GROUP" "$INPUT"
test 'States'           "$STATE" "$_DEBUG_STATE" "$INPUT"

INPUT='  (   A   )   (   B   )'
LEVEL='0 ( 1 A 1 ) 0 ( 1 B 1 ) 0'
GROUP='0 ( 1 A 1 ) 0 ( 2 B 2 ) 0'
STATE='0 ( 0 A 1 ) 1 ( 1 B 2 ) 2'; FINAL="2"
preparse $INPUT; RETVAL="$?"                   # intentionally unquoted
test 'Return value'     "0"      "$RETVAL"
test 'Bracket level'    "$LEVEL" "$_DEBUG_LEVEL" "$INPUT"
test 'Group numbers'    "$GROUP" "$_DEBUG_GROUP" "$INPUT"
test 'States'           "$STATE" "$_DEBUG_STATE" "$INPUT"

INPUT='  (   A   (   B   )   )'
LEVEL='0 ( 1 A 1 ( 2 B 2 ) 1 ) 0'
GROUP='0 ( 1 A 1 ( 2 B 2 ) 1 ) 0'
STATE='0 ( 0 A 2 ( 2 B 3 ) 3 ) 3'; FINAL="2"
preparse $INPUT; RETVAL="$?"                   # intentionally unquoted
test 'Return value'     "0"      "$RETVAL"
test 'Bracket level'    "$LEVEL" "$_DEBUG_LEVEL" "$INPUT"
test 'Group numbers'    "$GROUP" "$_DEBUG_GROUP" "$INPUT"
test 'States'           "$STATE" "$_DEBUG_STATE" "$INPUT"

INPUT='  (   (   A   B   )   )'
LEVEL='0 ( 1 ( 2 A 2 B 2 ) 1 ) 0'
GROUP='0 ( 1 ( 2 A 2 B 2 ) 1 ) 0'
STATE='0 ( 0 ( 0 A 3 B 2 ) 2 ) 2'; FINAL="2"
preparse $INPUT; RETVAL="$?"                   # intentionally unquoted
test 'Return value'     "0"      "$RETVAL"
test 'Bracket level'    "$LEVEL" "$_DEBUG_LEVEL" "$INPUT"
test 'Group numbers'    "$GROUP" "$_DEBUG_GROUP" "$INPUT"
test 'States'           "$STATE" "$_DEBUG_STATE" "$INPUT"

INPUT='  (   (   A   )   B   )'
LEVEL='0 ( 1 ( 2 A 2 ) 1 B 1 ) 0'
GROUP='0 ( 1 ( 2 A 2 ) 1 B 1 ) 0'
STATE='0 ( 0 ( 0 A 2 ) 2 B 1 ) 1'; FINAL="2"
preparse $INPUT; RETVAL="$?"                   # intentionally unquoted
test 'Return value'     "0"      "$RETVAL"
test 'Bracket level'    "$LEVEL" "$_DEBUG_LEVEL" "$INPUT"
test 'Group numbers'    "$GROUP" "$_DEBUG_GROUP" "$INPUT"
test 'States'           "$STATE" "$_DEBUG_STATE" "$INPUT"

INPUT='  [   A   ]'
LEVEL='0 [ 1 A 1 ] 0'
GROUP='0 [ 1 A 1 ] 0'
STATE='0 [ 0 A 1 ] 1'; FINAL="0 1"
preparse $INPUT; RETVAL="$?"                   # intentionally unquoted
test 'Return value'     "0"      "$RETVAL"
test 'Bracket level'    "$LEVEL" "$_DEBUG_LEVEL" "$INPUT"
test 'Group numbers'    "$GROUP" "$_DEBUG_GROUP" "$INPUT"
test 'States'           "$STATE" "$_DEBUG_STATE" "$INPUT"

# FIXME!! End values of paren alternatives!
INPUT='  (   A   |   B   )'
LEVEL='0 ( 1 A 1 | 1 B 1 ) 0'
GROUP='0 ( 1 A 1 | 1 B 1 ) 0'
STATE='0 ( 0 A 1 | 0 B 1 ) 1'; FINAL=1
preparse $INPUT; RETVAL="$?"                   # intentionally unquoted
test 'Return value'     "0"      "$RETVAL"
test 'Bracket level'    "$LEVEL" "$_DEBUG_LEVEL" "$INPUT"
test 'Group numbers'    "$GROUP" "$_DEBUG_GROUP" "$INPUT"
test 'States'           "$STATE" "$_DEBUG_STATE" "$INPUT"

tests_done
exit


    ARGS='  [ NAME ]'
EXPECTED='0 [ 0 NAME 0 ] 0'
out $ARGS        # intentionally unquoted
preparse $ARGS   # intentionally unquoted

    ARGS='  (   (   A   (   B   |   C   [   D   ]   )   )   |   (   E   )   (   F   )   )'
EXPECTED='0 ( 0 ( 0 A 1 ( 1 B 2 | 1 C 3 [ 3 D 3 ] 3 ) 3 ) 3 | 0 ( 0 E 4 ) 4 ( 4 F 5 ) 5 ) 5'
#         0 ( 0 ( 0   1 ( 1   2 | 1   3 [ 3   3 ] 3 ) 3 ) 3 | 0 ( 0   4 ) 4 ( 4   5 ) 5 ) 5
# LEVEL:    1   2   2   3   3   3   3   4   4   4   3   2   1   2   2   2   2   2   2   1
# START:    0   0       1               3                       2       2   2       2   1

# before '|' = set group endstate
#   if type bracket = endstate = startstate
#   if type paren   = endstate = next state


out $ARGS        # intentionally unquoted
preparse $ARGS   # intentionally unquoted

echo ">$BEG2<"

#[eof]
